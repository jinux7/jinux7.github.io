<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jinux</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-06-08T01:28:29.261Z</updated>
  <id>/</id>
  
  <author>
    <name>jinux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nodejs常驻后台运行</title>
    <link href="/2020/06/05/Nodejs%E5%B8%B8%E9%A9%BB%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/"/>
    <id>/2020/06/05/Nodejs常驻后台运行/</id>
    <published>2020-06-05T09:05:27.000Z</published>
    <updated>2020-06-08T01:28:29.261Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs程序在后台运行<br><a id="more"></a></p><h1 id="Nodejs常驻后台运行"><a href="#Nodejs常驻后台运行" class="headerlink" title="Nodejs常驻后台运行"></a>Nodejs常驻后台运行</h1><p>nodejs是通过命令行方式执行，当用户的xshell断开时Nodejs也就停止运行了。下面介绍几种办法让Nodejs常驻在后台运行</p><h2 id="pm2-推荐"><a href="#pm2-推荐" class="headerlink" title="pm2(推荐)"></a>pm2(推荐)</h2><p><a href="http://pm2.io/" target="_blank" rel="noopener">官网地址</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pm2</span><br><span class="line">pm2 start app.js        <span class="comment">// 启动</span></span><br><span class="line">pm2 start app.js -i max <span class="comment">//启动 使用所有CPU核心的集群</span></span><br><span class="line">pm2 stop app.js         <span class="comment">// 停止</span></span><br><span class="line">pm2 stop all            <span class="comment">// 停止所有</span></span><br><span class="line">pm2 restart app.js      <span class="comment">// 重启</span></span><br><span class="line">pm2 restart all         <span class="comment">// 重启所有</span></span><br><span class="line">pm2 <span class="keyword">delete</span>  app.js      <span class="comment">// 关闭</span></span><br></pre></td></tr></table></figure></p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup node app.js &amp;</span><br></pre></td></tr></table></figure><h2 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h2><p><a href="https://github.com/nodejitsu/forever" target="_blank" rel="noopener">github地址</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install forever -g</span><br><span class="line">forever start app.js    <span class="comment">//启动</span></span><br><span class="line">forever stop app.js     <span class="comment">//关闭</span></span><br><span class="line">forever stopall         <span class="comment">//关闭全部</span></span><br><span class="line">forever restart app.js  <span class="comment">//重启</span></span><br><span class="line">forever restartall      <span class="comment">//重启全部</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs程序在后台运行&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="linux" scheme="/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>前端埋点</title>
    <link href="/2020/05/29/%E5%89%8D%E7%AB%AF%E5%9F%8B%E7%82%B9/"/>
    <id>/2020/05/29/前端埋点/</id>
    <published>2020-05-29T03:13:42.000Z</published>
    <updated>2020-05-29T06:16:56.139Z</updated>
    
    <content type="html"><![CDATA[<p>全面的介绍前端埋点知识<br><a id="more"></a></p><h1 id="前端埋点"><a href="#前端埋点" class="headerlink" title="前端埋点"></a>前端埋点</h1><p>所谓「埋点」，就是在正常的功能逻辑中添加统计逻辑。拿统计微信右上角「+」的点击次数为例，上报的数据可以采用KEY-VALUE形式，我们定义KEY为「CLICK_ADD_BTN」，VALUE的值为点击的次数。当用户点击「+」时，展示菜单的代码会通过按钮的「回调」来触发执行，程序猿在业务代码执行完后，又加上了统计代码，把「CLICK_ADD_BTN」对应的VALUE加1，「+」被统计到了一次使用。<br>目前常见的前端埋点技术有3类：代码埋点、可视化埋点、无埋点（无埋点属于埋点的一个子集）。</p><h2 id="代码埋点："><a href="#代码埋点：" class="headerlink" title="代码埋点："></a>代码埋点：</h2><p>控件操作发生时通过预先写好的代码来发送数据。<br>优点：</p><ul><li>控制发送数据时间，事件自定义属性详细记录</li></ul><p>缺点：</p><ul><li>时间、人力成本大，数据传输的时效性。</li></ul><h2 id="可视化埋点："><a href="#可视化埋点：" class="headerlink" title="可视化埋点："></a>可视化埋点：</h2><p>利用可视化交互手段，通过可视化界面配置控件操作与事件操作发生关系。通过后台截屏的方式采集数据。<br>优点：</p><ul><li>成本低，速度快</li></ul><p>缺点：</p><ul><li>行为记录信息少，支持的分析方式少</li></ul><h2 id="无埋点："><a href="#无埋点：" class="headerlink" title="无埋点："></a>无埋点：</h2><p>Growing IO和Heap analytics，这2家是国内与国外的无埋点技术公司代表。用户展现界面元素时，通过控件绑定触发事件，事件被触发的时候系统会有相应的接口让开发者处理这些行为。现在市面上主流无埋点做法有两种，一种是预先跟踪所有的渲染信息，一种是滞后跟踪的渲染信息。<br>优点：</p><ul><li>无需埋点，方便快捷</li></ul><p>缺点：</p><ul><li>行为记录信息少，传输压力大</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，关于埋点有无问题，可视化埋点和代码优劣问题，不管选择哪个都要从自身情况去考虑，自身分析场景来体验和对比，选择最适合自己的。适合自己的才是最好的。<br>这里推荐两篇介绍比较详细的前端埋点博文:<br><a href="http://www.imooc.com/article/27151" target="_blank" rel="noopener">第一篇</a><br><a href="https://blog.csdn.net/ywl570717586/article/details/89852222" target="_blank" rel="noopener">第二篇</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全面的介绍前端埋点知识&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>微前端</title>
    <link href="/2020/05/25/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    <id>/2020/05/25/微前端/</id>
    <published>2020-05-25T07:11:09.000Z</published>
    <updated>2020-05-25T07:53:46.365Z</updated>
    
    <content type="html"><![CDATA[<p>初探微前端<br><a id="more"></a></p><h1 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h1><p>微前端最近火了起来，作为紧跟技术潮流的笔者来说，当然要了解一下。<br>贴出一篇笔者觉得不错的文章，<a href="https://www.lizenghai.com/archives/40308.html#i-17" target="_blank" rel="noopener">Single-Spa + Vue Cli 微前端落地指南</a>。这篇文章写得很不错，笔者就是按照他的思路一步一步的完成了一个微前端的demo。但是，笔者的demo只包含vue，父项目和子项目都是用的vue搭建的，相对来说比较简单些，而且，在实际开发的项目中都是一样的框架也是最好的选择。<br>最后，自己用vue写的一个demo，完成了主框架引入了两个子框架。<br><a href="https://github.com/jinux7/study-collections/tree/master/%E5%BE%AE%E5%89%8D%E7%AB%AF" target="_blank" rel="noopener">demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初探微前端&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>hash&amp;history单页面路由框架</title>
    <link href="/2020/05/18/hash-history%E5%8D%95%E9%A1%B5%E9%9D%A2%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6/"/>
    <id>/2020/05/18/hash-history单页面路由框架/</id>
    <published>2020-05-18T03:30:17.000Z</published>
    <updated>2020-05-18T05:20:29.624Z</updated>
    
    <content type="html"><![CDATA[<p>hash和history路由形式的单页面框架<br><a id="more"></a></p><h1 id="hash-amp-history单页面路由框架"><a href="#hash-amp-history单页面路由框架" class="headerlink" title="hash&amp;history单页面路由框架"></a>hash&amp;history单页面路由框架</h1><p>现在vue,react,angular三大框架已经垄断了前端的单页面应用，用起来很方便，今天笔者写两个hash和history路由的小框架，有时候小项目可能也能用到，相比其它框架可能会配置灵活些。在使用vue等框架之前的单页面应用都是这样做的。<br>细节不写了，附上demo代码：<br><a href="https://github.com/jinux7/study-collections/tree/master/hash%26history%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A1%86%E6%9E%B6" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hash和history路由形式的单页面框架&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>手写vue</title>
    <link href="/2020/04/27/%E6%89%8B%E5%86%99vue/"/>
    <id>/2020/04/27/手写vue/</id>
    <published>2020-04-27T05:54:30.000Z</published>
    <updated>2020-04-27T08:04:30.936Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个基础功能的vue<br><a id="more"></a></p><h1 id="手写vue"><a href="#手写vue" class="headerlink" title="手写vue"></a>手写vue</h1><p>实现一个非常简化版vue，暂时实现了<code>v-text,v-html,v-model,@eventName</code>指令，还有插值表达式<code>｛｛｝｝</code>,<br>一共写了4个类去实现，Vue是主类，Dep依赖收集类，Watcher是观察者类，Dep依赖收集去触发Watcher观察者定义的的方法，Compile类是用来解析html的dom元素的，解析的时候向对应的数据添加依赖，这样数据改变视图跟着改变。<br>下面是代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(option) &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = option.el &amp;&amp; <span class="built_in">document</span>.querySelector(option.el);</span><br><span class="line">    <span class="keyword">this</span>.$data = option.data;</span><br><span class="line">    <span class="keyword">this</span>.$methods = option.methods;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observer(<span class="keyword">this</span>.$data);</span><br><span class="line">    <span class="keyword">new</span> Compile(<span class="keyword">this</span>.el, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 给data值设置get，set的数据劫持</span></span><br><span class="line">  observer(daObj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> daObj === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> daObj) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = daObj[key];</span><br><span class="line">        <span class="keyword">if</span>(value &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">'object'</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.observer(value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep(); </span><br><span class="line">          <span class="built_in">Object</span>.defineProperty(daObj, key, &#123;</span><br><span class="line">            get() &#123;</span><br><span class="line">              Dep.target &amp;&amp; dep.push(Dep.target);</span><br><span class="line">              <span class="keyword">return</span> value;</span><br><span class="line">            &#125;,</span><br><span class="line">            set(val) &#123;</span><br><span class="line">              value = val;</span><br><span class="line">              <span class="comment">// 这里注意。依赖触发要在value=val的下边</span></span><br><span class="line">              dep.dispatch();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依赖类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.watchers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  push(watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.watchers.push(watcher);</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch() &#123;</span><br><span class="line">    <span class="keyword">this</span>.watchers.forEach(<span class="function"><span class="params">watcher</span>=&gt;</span> &#123;</span><br><span class="line">      watcher &amp;&amp; watcher.callback &amp;&amp; watcher.callback(); </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(callback) &#123;</span><br><span class="line">    Dep.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译模板字符串类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compile</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(el, vm) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parseHtml(el, vm);</span><br><span class="line">  &#125;</span><br><span class="line">  parseHtml(el, vm) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.from(el.childNodes).forEach(<span class="function"><span class="params">item</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 处理带有指令的节点元素</span></span><br><span class="line">      <span class="keyword">this</span>.updateDirect(item, vm);</span><br><span class="line">      <span class="keyword">if</span>(item.nodeType === <span class="number">1</span> &amp;&amp; item.childNodes.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归解析</span></span><br><span class="line">        <span class="keyword">this</span>.parseHtml(item, vm);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.nodeType === <span class="number">3</span> &amp;&amp; <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>.test(item.textContent)) &#123;</span><br><span class="line">        <span class="keyword">let</span> epx = <span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.updateText(item, vm, epx);</span><br><span class="line">        <span class="keyword">new</span> Watcher(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.updateText(item, vm, epx);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx);</span><br><span class="line">        Dep.target = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是指令节点</span></span><br><span class="line">  updateDirect(node, vm) &#123;</span><br><span class="line">    <span class="comment">// 如果元素节点的属性是一个json对象</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> node.attributes === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="comment">// 转换成数组</span></span><br><span class="line">      <span class="keyword">let</span> attrs = <span class="built_in">Array</span>.from(node.attributes);</span><br><span class="line">      <span class="keyword">if</span>(attrs.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;attrs.length; i++) &#123;</span><br><span class="line">          <span class="comment">// v-xxx指令</span></span><br><span class="line">          <span class="keyword">if</span>(<span class="regexp">/^v\-.+/</span>.test(attrs[i].name)) &#123;</span><br><span class="line">            <span class="keyword">let</span> handleStr = attrs[i].name.substring(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">let</span> epx = attrs[i].value;</span><br><span class="line">            <span class="keyword">this</span>[<span class="string">'dir'</span>+handleStr](node, vm, epx);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// @事件</span></span><br><span class="line">          <span class="keyword">if</span>(<span class="regexp">/^\@.+/</span>.test(attrs[i].name))&#123;</span><br><span class="line">            <span class="keyword">let</span> eventName = attrs[i].name.substring(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">let</span> callbackName = attrs[i].value;</span><br><span class="line">            <span class="keyword">this</span>[<span class="string">'eventHandler'</span>](node, vm, eventName, callbackName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理指令节点数据响应</span></span><br><span class="line">  dirtext(node, vm, epx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateText(node, vm, epx);</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateText(node, vm, epx);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx);</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dirhtml(node, vm, epx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateHtml(node, vm, epx);</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateHtml(node, vm, epx);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx);</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dirmodel(node, vm, epx) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateValue(node, vm, epx);</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateValue(node, vm, epx);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx);</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 添加input事件</span></span><br><span class="line">    node.addEventListener(<span class="string">'input'</span>, (ev)=&gt; &#123;</span><br><span class="line">      <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span> + epx + <span class="string">'="'</span> + ev.target.value + <span class="string">'"'</span>);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理指令事件</span></span><br><span class="line">  eventHandler(node, vm, eventName, callbackName) &#123;</span><br><span class="line">    node.addEventListener(eventName, vm.$methods[callbackName]||loop, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更改元素节点的textContent</span></span><br><span class="line">  updateText(node, vm, epx) &#123;</span><br><span class="line">    node.textContent = <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span>+epx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更改元素节点的innerHTML</span></span><br><span class="line">  updateHtml(node, vm, epx) &#123;</span><br><span class="line">    node.innerHTML = <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span>+epx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更改input元素的value</span></span><br><span class="line">  updateValue(node, vm, epx) &#123;</span><br><span class="line">    node.value = <span class="built_in">eval</span>(<span class="string">'vm.$data.'</span>+epx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>代码不多，但是基本功能已经实现。<br><a href="https://github.com/jinux7/study-collections/tree/master/%E6%89%8B%E5%86%99vue" target="_blank" rel="noopener">代码点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现一个基础功能的vue&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>手写vuex</title>
    <link href="/2020/04/21/%E6%89%8B%E5%86%99vuex/"/>
    <id>/2020/04/21/手写vuex/</id>
    <published>2020-04-21T06:52:06.000Z</published>
    <updated>2020-04-21T07:16:43.862Z</updated>
    
    <content type="html"><![CDATA[<p>简单的实现vuex的功能<br><a id="more"></a></p><h1 id="手写vuex"><a href="#手写vuex" class="headerlink" title="手写vuex"></a>手写vuex</h1><p>vuex是vue的一个状态管理插件，现在使用的场景非常多，今天，自己简单的实现一下vuex的几个小功能，如<code>state,getter,commit,mutations,dispatch,actions</code>,暂时先实现这么多，有精力的话再补充<code>module,map等</code>。</p><h2 id="vuex在vue中的使用"><a href="#vuex在vue中的使用" class="headerlink" title="vuex在vue中的使用"></a>vuex在vue中的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// store.js文件，也就是配置store的文件</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  getter: &#123;</span><br><span class="line">    getterCount(state) &#123;</span><br><span class="line">      return state.count + 5;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add(state, num) &#123;</span><br><span class="line">      state.count += num; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    addAction(state, num) &#123;</span><br><span class="line">      setTimeout(()=&gt; &#123;</span><br><span class="line">        state.commit(&apos;add&apos;, num);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// vue的main.js文件中引入store</span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br><span class="line"></span><br><span class="line">// vue具体页面使用</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h2&gt;state-&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;getter-&gt;&#123;&#123;$store.getter.getterCount&#125;&#125;&lt;/h2&gt;  </span><br><span class="line">    &lt;h2&gt;computed-&gt;&#123;&#123;mill&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;onAdd&quot;&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;onAddDispatch&quot;&gt;addDispatch&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    mill() &#123;</span><br><span class="line">      return this.$store.state.count + 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onAdd() &#123;</span><br><span class="line">      this.$store.commit(&apos;add&apos;, 15);</span><br><span class="line">    &#125;,</span><br><span class="line">    onAddDispatch() &#123;</span><br><span class="line">      this.$store.dispatch(&apos;addAction&apos;, 10);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="vuex的实现代码"><a href="#vuex的实现代码" class="headerlink" title="vuex的实现代码"></a>vuex的实现代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">let Vue;</span><br><span class="line">class Store &#123;</span><br><span class="line">  constructor(options = &#123;&#125;) &#123;</span><br><span class="line">    this.options = options;</span><br><span class="line">    this.vueState = new Vue(&#123;</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          state: options.state</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 处理getter操作</span><br><span class="line">    this.getter = &#123;&#125;;</span><br><span class="line">    Object.keys(this.options.getter).forEach(item=&gt; &#123;</span><br><span class="line">      Object.defineProperty(this.getter, item, &#123;</span><br><span class="line">        get: ()=&gt; &#123;</span><br><span class="line">          return this.options.getter[item](this.options.state);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // commit方法和mutations</span><br><span class="line">  commit(type, val) &#123;</span><br><span class="line">    Object.keys(this.options.mutations).forEach(item=&gt; &#123;</span><br><span class="line">      if(item === type) &#123;</span><br><span class="line">        this.options.mutations[item](this.options.state, val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // dispatch方法和actions</span><br><span class="line">  dispatch(type, val) &#123;</span><br><span class="line">    Object.keys(this.options.actions).forEach(item=&gt; &#123;</span><br><span class="line">      if(item === type) &#123;</span><br><span class="line">        this.options.actions[item](this, val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 获取Store的state，来源于this.vueState，是Vue的一个实例，可以实现了store.state的数据绑定更新页面</span><br><span class="line">  get state () &#123;</span><br><span class="line">      return this.vueState.state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 供Vue.use()调用 </span><br><span class="line">function install(_Vue) &#123;</span><br><span class="line">  Vue = _Vue;</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">      beforeCreate: function () &#123;</span><br><span class="line">          const options = this.$options;</span><br><span class="line">          if (options.store) &#123;</span><br><span class="line">              this.$store = options.store;</span><br><span class="line">          &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">              this.$store = options.parent.$store;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的实现vuex的功能&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="vue" scheme="/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>WebAssembly入门</title>
    <link href="/2020/04/15/WebAssembly%E5%85%A5%E9%97%A8/"/>
    <id>/2020/04/15/WebAssembly入门/</id>
    <published>2020-04-15T03:15:30.000Z</published>
    <updated>2020-04-27T07:53:06.088Z</updated>
    
    <content type="html"><![CDATA[<p>WebAssembly简单实例<br><a id="more"></a></p><h1 id="WebAssembly入门"><a href="#WebAssembly入门" class="headerlink" title="WebAssembly入门"></a>WebAssembly入门</h1><p>WebAssembly是一门新技术，可以将c,c++,java等文件编译成.wasm文件，再被js引入到html中使用。<br>今天我介绍一种简单的方式生成.wasm文件，不需要使用繁琐的系统工具来完成。<br><a href="https://webassembly.studio/" target="_blank" rel="noopener">在线webassembly</a>,这个网站可以在线写c语言代码，在线打包成.wasm文件，还可以看例子，学习具体的使用。<br>贴一个小例子，也是按照这个在线编辑器copy下来的，<a href="https://github.com/jinux7/study-collections/tree/master/webAssembly" target="_blank" rel="noopener">demo点这里</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WebAssembly简单实例&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>点击或触摸事件中的相关X,Y介绍</title>
    <link href="/2020/04/13/%E7%82%B9%E5%87%BB%E6%88%96%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3X-Y%E4%BB%8B%E7%BB%8D/"/>
    <id>/2020/04/13/点击或触摸事件中的相关X-Y介绍/</id>
    <published>2020-04-13T01:30:07.000Z</published>
    <updated>2020-04-13T01:54:39.236Z</updated>
    
    <content type="html"><![CDATA[<p>点击或触摸事件中，事件对象的clientX,pageX,screenX,offsetX,x介绍<br><a id="more"></a></p><h1 id="点击或触摸事件中的相关X-Y介绍"><a href="#点击或触摸事件中的相关X-Y介绍" class="headerlink" title="点击或触摸事件中的相关X,Y介绍"></a>点击或触摸事件中的相关X,Y介绍</h1><h2 id="位置属性"><a href="#位置属性" class="headerlink" title="位置属性"></a>位置属性</h2><p>我们在使用点击事件时，想获取当前鼠标在页面中的位置，可以把事件对象打印出来，看到了下图中的一些相关于x，y的属性。<br><img src="/2020/04/13/点击或触摸事件中的相关X-Y介绍/1.png" alt="img"></p><h2 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h2><h3 id="clientX、clientY"><a href="#clientX、clientY" class="headerlink" title="clientX、clientY"></a>clientX、clientY</h3><p>点击位置距离当前body可视区域的x，y坐标</p><h3 id="pageX、pageY"><a href="#pageX、pageY" class="headerlink" title="pageX、pageY"></a>pageX、pageY</h3><p>对于整个页面来说，包括了被卷去的body部分的长度</p><h3 id="screenX、screenY"><a href="#screenX、screenY" class="headerlink" title="screenX、screenY"></a>screenX、screenY</h3><p>点击位置距离当前电脑屏幕的x，y坐标</p><h3 id="offsetX、offsetY"><a href="#offsetX、offsetY" class="headerlink" title="offsetX、offsetY"></a>offsetX、offsetY</h3><p>相对于带有定位的父盒子的x，y坐标</p><h3 id="x、y"><a href="#x、y" class="headerlink" title="x、y"></a>x、y</h3><p>和screenX、screenY一样</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2020/04/13/点击或触摸事件中的相关X-Y介绍/2.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击或触摸事件中，事件对象的clientX,pageX,screenX,offsetX,x介绍&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>web全景图之pannellum</title>
    <link href="/2020/04/09/web%E5%85%A8%E6%99%AF%E5%9B%BE%E4%B9%8Bpannellum/"/>
    <id>/2020/04/09/web全景图之pannellum/</id>
    <published>2020-04-09T06:32:37.000Z</published>
    <updated>2020-04-09T07:12:53.174Z</updated>
    
    <content type="html"><![CDATA[<p>开发web全景图的工具库pannellum<br><a id="more"></a></p><h1 id="web全景图之pannellum"><a href="#web全景图之pannellum" class="headerlink" title="web全景图之pannellum"></a>web全景图之pannellum</h1><p>最近需要开发一个室内全景图的项目，类似于贝壳的VR看房，直接用three.js开发成本太高，于是在网上找到了pannellum这个工具库，不依赖其它的库，而且还小，使用简单。</p><h2 id="pannellum官网地址"><a href="#pannellum官网地址" class="headerlink" title="pannellum官网地址"></a>pannellum官网地址</h2><p><a href="https://pannellum.org/" target="_blank" rel="noopener">pannellum官网地址</a></p><h2 id="自己做了一个小demo"><a href="#自己做了一个小demo" class="headerlink" title="自己做了一个小demo"></a>自己做了一个小demo</h2><p><a href="https://github.com/jinux7/study-collections/tree/master/pannellum-web%E5%85%A8%E6%99%AF" target="_blank" rel="noopener">demo地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发web全景图的工具库pannellum&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="3D" scheme="/tags/3D/"/>
    
  </entry>
  
  <entry>
    <title>AlloyFinger手势库分析</title>
    <link href="/2020/03/26/AlloyFinger%E6%89%8B%E5%8A%BF%E5%BA%93%E5%88%86%E6%9E%90/"/>
    <id>/2020/03/26/AlloyFinger手势库分析/</id>
    <published>2020-03-26T09:13:31.000Z</published>
    <updated>2020-03-27T01:24:40.048Z</updated>
    
    <content type="html"><![CDATA[<p>移动端手势库AlloyFinger分析<br><a id="more"></a></p><h1 id="AlloyFinger手势库分析"><a href="#AlloyFinger手势库分析" class="headerlink" title="AlloyFinger手势库分析"></a>AlloyFinger手势库分析</h1><p>AlloyFinger这个移动端手势库是腾讯的AlloyTeam团队开发的，体积小，功能强大，简单易用，具体的使用方法见<a href="https://github.com/AlloyTeam/AlloyFinger" target="_blank" rel="noopener">AlloyFinger github</a><br>这两天闲暇的时候好好的读了几遍这个库的代码，写好了注释，理解了作者的思路，受益匪浅。<br>注释代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc 移动端手势库</span><br><span class="line"> * @desc 分析</span><br><span class="line"> */</span><br><span class="line">;</span><br><span class="line">(function(window) &#123;</span><br><span class="line">  // 获取两点间距离工具函数</span><br><span class="line">  function getLen(v) &#123;</span><br><span class="line">      return Math.sqrt(v.x * v.x + v.y * v.y);</span><br><span class="line">  &#125;</span><br><span class="line">  // dot和getAngle函数用来算两次手势状态之间的夹角, cross函数用来算方向的, getRotateAngle函数算手势真正的角度的</span><br><span class="line">  function dot(v1, v2) &#123;</span><br><span class="line">      return v1.x * v2.x + v1.y * v2.y;</span><br><span class="line">  &#125;</span><br><span class="line"> // 求两次手势状态之间的夹角</span><br><span class="line">  function getAngle(v1, v2) &#123;</span><br><span class="line">      var mr = getLen(v1) * getLen(v2);</span><br><span class="line">      if (mr === 0) return 0;</span><br><span class="line">      var r = dot(v1, v2) / mr;</span><br><span class="line">      if (r &gt; 1) r = 1;</span><br><span class="line">      return Math.acos(r);</span><br><span class="line">  &#125;</span><br><span class="line">  // 利用cross结果的正负来判断旋转的方向(大于0为逆时针, 小于0为顺时针)</span><br><span class="line">  function cross(v1, v2) &#123;</span><br><span class="line">      return v1.x * v2.y - v2.x * v1.y;</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果cross大于0那就是逆时针对于屏幕是正角,对于第一象限是负角,所以 角度 * -1, 然后角度单位换算</span><br><span class="line">  function getRotateAngle(v1, v2) &#123;</span><br><span class="line">      var angle = getAngle(v1, v2);</span><br><span class="line">      if (cross(v1, v2) &gt; 0) &#123;</span><br><span class="line">          angle *= -1;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return angle * 180 / Math.PI;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var HandlerAdmin = function(el) &#123;</span><br><span class="line">      this.handlers = [];</span><br><span class="line">      this.el = el;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 函数管理构造函数</span><br><span class="line">  function HandlerAdmin(el) &#123;</span><br><span class="line">    this.handlers = [];</span><br><span class="line">    this.el = el;</span><br><span class="line">  &#125;</span><br><span class="line">  // 添加需要触发的函数</span><br><span class="line">  HandlerAdmin.prototype.add = function(handler) &#123;</span><br><span class="line">    this.handlers.push(handler);</span><br><span class="line">  &#125;</span><br><span class="line">  // 删除需要触发的函数</span><br><span class="line">  HandlerAdmin.prototype.del = function(handler) &#123;</span><br><span class="line">    // 如果什么也不传，清空函数数组</span><br><span class="line">    if(!handler) &#123;</span><br><span class="line">      this.handlers = [];</span><br><span class="line">    &#125;</span><br><span class="line">    // 比对数组中的函数，并且删除它</span><br><span class="line">    for(var i=this.handlers.length; i&gt;=0; i--) &#123;</span><br><span class="line">      if(this.handlers[i] === handler) &#123;</span><br><span class="line">          this.handlers.splice(i, 1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 运行需要触发的函数</span><br><span class="line">  HandlerAdmin.prototype.dispatch = function() &#123;</span><br><span class="line">    for(var i=0,len=this.handlers.length; i&lt;len; i++) &#123;</span><br><span class="line">        var handler = this.handlers[i];</span><br><span class="line">        // 运行这些函数的时候，是作为元素的事件触发的，所以，这些函数的this要指向这个元素</span><br><span class="line">        if(typeof handler === &apos;function&apos;) handler.apply(this.el, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 初始化函数管理对象</span><br><span class="line">  function wrapFunc(el, handler) &#123;</span><br><span class="line">    var handlerAdmin = new HandlerAdmin(el);</span><br><span class="line">    handlerAdmin.add(handler);</span><br><span class="line">    return handlerAdmin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 手势库构造函数</span><br><span class="line">  function AlloyFinger(el, option) &#123;</span><br><span class="line">    // 获取添加事件的元素</span><br><span class="line">    this.element = typeof el === &apos;string&apos; ? document.querySelector(el) : el;</span><br><span class="line">    // 因为添加事件后这些方法的执行上下文是this.element，所以给方法bind JinuxFinger这个执行上下文</span><br><span class="line">    this.start = this.start.bind(this);</span><br><span class="line">    this.move = this.move.bind(this);</span><br><span class="line">    this.end = this.end.bind(this);</span><br><span class="line">    this.cancel = this.cancel.bind(this);</span><br><span class="line">    // 给这个元素添加事件</span><br><span class="line">    this.element.addEventListener(&quot;touchstart&quot;, this.start, false);</span><br><span class="line">    this.element.addEventListener(&quot;touchmove&quot;, this.move, false);</span><br><span class="line">    this.element.addEventListener(&quot;touchend&quot;, this.end, false);</span><br><span class="line">    this.element.addEventListener(&quot;touchcancel&quot;, this.cancel, false);</span><br><span class="line">    // 定义一些实例属性</span><br><span class="line">    this.preV = &#123; x: null, y: null &#125;; // 两个手指间的x距离和y距离</span><br><span class="line">    this.pinchStartLen = null; // 捏拽的长度</span><br><span class="line">    this.zoom = 1; // 缩放比例</span><br><span class="line">    this.isDoubleTap = false; // 是否是双击</span><br><span class="line">    var noop = function() &#123;&#125; // 空函数</span><br><span class="line">    // 实例化JinuxFinger时，设置的手势回调函数</span><br><span class="line">    this.rotate = wrapFunc(this.element, option.rotate || noop); // 旋转</span><br><span class="line">    this.touchStart = wrapFunc(this.element, option.touchStart || noop); // 触摸开始  </span><br><span class="line">    this.multipointStart = wrapFunc(this.element, option.multipointStart || noop); // 多个手指触摸开始 </span><br><span class="line">    this.multipointEnd = wrapFunc(this.element, option.multipointEnd || noop); // 多个手指触摸结束，如4个手指触摸，屏幕上剩下1个或不剩都会触发</span><br><span class="line">    this.pinch = wrapFunc(this.element, option.pinch || noop); // 两个手指捏拽</span><br><span class="line">    this.swipe = wrapFunc(this.element, option.swipe || noop); // 上下左右滑动，手指离开时触发</span><br><span class="line">    this.tap = wrapFunc(this.element, option.tap || noop); // 无论是单击还是双击都会触发</span><br><span class="line">    this.doubleTap = wrapFunc(this.element, option.doubleTap || noop); // 双击触发</span><br><span class="line">    this.longTap = wrapFunc(this.element, option.longTap || noop); // 单手指长按触发，750ms</span><br><span class="line">    this.singleTap = wrapFunc(this.element, option.singleTap || noop); // 单击触发，250ms</span><br><span class="line">    this.pressMove = wrapFunc(this.element, option.pressMove || noop); // 1个手指屏幕上移动触发</span><br><span class="line">    this.twoFingerPressMove = wrapFunc(this.element, option.twoFingerPressMove || noop); // 2个以上手指屏幕上移动触发</span><br><span class="line">    this.touchMove = wrapFunc(this.element, option.touchMove || noop); // 无论几个手指在屏幕上移动都会触发</span><br><span class="line">    this.touchEnd = wrapFunc(this.element, option.touchEnd || noop); // 触摸结束都会触发</span><br><span class="line">    this.touchCancel = wrapFunc(this.element, option.touchCancel || noop); // 事件简单的说是在移动端发生了触摸中断，一般情况下就是优先级比当前活动更高的事件时，才会触发的。比如正在看新闻，手指滑动屏幕的时候，突然来电话，直接中断了触摸事件，跳转到了通话，页面此时就触发了touchcancel事件。这个事件不容易在浏览器的模拟器中模拟，之前我在用电脑的任务栏切换的时候，受到启发，可以试试在浏览器模拟器触摸的同时，按下键盘上的Alt+Tab键，果然触发了touchcancel事件，有兴趣的小伙伴可以试一下。</span><br><span class="line">    </span><br><span class="line">    this._cancelAllHandler = this.cancelAll.bind(this);</span><br><span class="line">    // 触发window的scroll事件时，清除现有touch事件的回调函数执行</span><br><span class="line">    window.addEventListener(&apos;scroll&apos;, this._cancelAllHandler);</span><br><span class="line"></span><br><span class="line">    this.delta = null; // 双击的间隔时间</span><br><span class="line">    this.last = null; // 相对于下一次点击，前一次点击的时间</span><br><span class="line">    this.now = null; // 当前点击保存用的时间，也可以理解为相对于上一次点击，这个是当前点击的时间</span><br><span class="line">    this.tapTimeout = null;</span><br><span class="line">    this.singleTapTimeout = null;</span><br><span class="line">    this.longTapTimeout = null;</span><br><span class="line">    this.swipeTimeout = null;</span><br><span class="line">    this.x1 = this.x2 = this.y1 = this.y2 = null;</span><br><span class="line">    this.preTapPosition = &#123; x: null, y: null &#125;; // 相对于下次点击，前一次点击手指x,y坐标的保存对象</span><br><span class="line">  &#125;</span><br><span class="line">  AlloyFinger.prototype = &#123;</span><br><span class="line">    start: function (evt) &#123;</span><br><span class="line">      if (!evt.touches) return; // 屏幕上没有手指则返回</span><br><span class="line">      this.now = Date.now(); // 设置touch开始时的时间</span><br><span class="line">      this.x1 = evt.touches[0].pageX; // 第一个手指触点相对于HTML文档左边沿的的X坐标. 当存在水平滚动的偏移时, 这个值包含了水平滚动</span><br><span class="line">      this.y1 = evt.touches[0].pageY; // 第一个手指触点相对于HTML文档左边沿的的Y坐标</span><br><span class="line">      this.delta = this.now - (this.last || this.now); // 双击的间隔时间</span><br><span class="line">      this.touchStart.dispatch(evt, this.element); // 触发了touchStart回调函数</span><br><span class="line">      if (this.preTapPosition.x !== null) &#123; // 如果不为null，说明之前已经有点击了</span><br><span class="line">          // 判断是否满足手指双击条件</span><br><span class="line">          this.isDoubleTap = (this.delta &gt; 0 &amp;&amp; this.delta &lt;= 250 &amp;&amp; Math.abs(this.preTapPosition.x - this.x1) &lt; 30 &amp;&amp; Math.abs(this.preTapPosition.y - this.y1) &lt; 30);</span><br><span class="line">          if (this.isDoubleTap) clearTimeout(this.singleTapTimeout);</span><br><span class="line">      &#125;</span><br><span class="line">      this.preTapPosition.x = this.x1; // 保存当前手指x坐标</span><br><span class="line">      this.preTapPosition.y = this.y1;// 保存当前手指y坐标</span><br><span class="line">      this.last = this.now; // 保存当前时间</span><br><span class="line">      var preV = this.preV, </span><br><span class="line">          len = evt.touches.length; // 现在屏幕上有多少个手指</span><br><span class="line">      if (len &gt; 1) &#123; // 两个手指以上触摸情况</span><br><span class="line">          this._cancelLongTap(); // 清除长按回调函数的执行</span><br><span class="line">          this._cancelSingleTap(); // 清除点击函数的执行</span><br><span class="line">          // 计算两个手指x,y的距离</span><br><span class="line">          var v = &#123; x: evt.touches[1].pageX - this.x1, y: evt.touches[1].pageY - this.y1 &#125;;</span><br><span class="line">          // 赋值给preV</span><br><span class="line">          preV.x = v.x; </span><br><span class="line">          preV.y = v.y;</span><br><span class="line">          this.pinchStartLen = getLen(preV); // 计算出两个手指间的距离</span><br><span class="line">          this.multipointStart.dispatch(evt, this.element); // 触发多点触碰函数回调</span><br><span class="line">      &#125;</span><br><span class="line">      this._preventTap = false; // 长按是否回调执行，否 </span><br><span class="line">      this.longTapTimeout = setTimeout(function () &#123; // 长按触发回调函数的定时器</span><br><span class="line">          this.longTap.dispatch(evt, this.element); // 触发长按回调函数</span><br><span class="line">          this._preventTap = true; // 长按是否回调执行，是</span><br><span class="line">      &#125;.bind(this), 750); // 长按是手指按下750ms后触发</span><br><span class="line">  &#125;,</span><br><span class="line">  move: function (evt) &#123;</span><br><span class="line">      if (!evt.touches) return; // 没有touches属性则返回</span><br><span class="line">      var preV = this.preV, // 两个手指间距离暂存preV里</span><br><span class="line">          len = evt.touches.length, // 屏幕上的手指数</span><br><span class="line">          currentX = evt.touches[0].pageX, // 屏幕上第一个手指的pageX暂存</span><br><span class="line">          currentY = evt.touches[0].pageY; // 屏幕上第一个手指的pageY暂存</span><br><span class="line">      this.isDoubleTap = false; // 手指移动了，就不是双击了</span><br><span class="line">      if (len &gt; 1) &#123; // 手指大于2个情况</span><br><span class="line">          var sCurrentX = evt.touches[1].pageX, // 屏幕上第2个手指的pageX暂存</span><br><span class="line">              sCurrentY = evt.touches[1].pageY; // 屏幕上第2个手指的pageY暂存</span><br><span class="line">          // 两个手指间距离</span><br><span class="line">          var v = &#123; x: evt.touches[1].pageX - currentX, y: evt.touches[1].pageY - currentY &#125;;</span><br><span class="line"></span><br><span class="line">          if (preV.x !== null) &#123;</span><br><span class="line">              if (this.pinchStartLen &gt; 0) &#123; // move之前两指间的距离如果大于0情况</span><br><span class="line">                  evt.zoom = getLen(v) / this.pinchStartLen; // move后的距离/move前的，就是捏拽的比例</span><br><span class="line">                  this.pinch.dispatch(evt, this.element); // 触发捏拽回调，并将zoom属性传递到事件对象里</span><br><span class="line">              &#125;</span><br><span class="line">              // 获取手指移动的角度</span><br><span class="line">              evt.angle = getRotateAngle(v, preV);</span><br><span class="line">              this.rotate.dispatch(evt, this.element); // 触发旋转回调函数</span><br><span class="line">          &#125;</span><br><span class="line">          preV.x = v.x; // move时将现在两指间的距离x赋值给preV</span><br><span class="line">          preV.y = v.y; // move时将现在两指间的距离y赋值给preV</span><br><span class="line"></span><br><span class="line">          if (this.x2 !== null &amp;&amp; this.sx2 !== null) &#123; // 因为是两个手指，所以取的是两个手指中间的值，两次move之间的偏移量,参考下变一个手指情况</span><br><span class="line">              evt.deltaX = (currentX - this.x2 + sCurrentX - this.sx2) / 2;</span><br><span class="line">              evt.deltaY = (currentY - this.y2 + sCurrentY - this.sy2) / 2;</span><br><span class="line">          &#125; else &#123; // 第一次移动都为0</span><br><span class="line">              evt.deltaX = 0;</span><br><span class="line">              evt.deltaY = 0;</span><br><span class="line">          &#125;</span><br><span class="line">          this.twoFingerPressMove.dispatch(evt, this.element); // 两个以上手指移动的事件回调</span><br><span class="line"></span><br><span class="line">          this.sx2 = sCurrentX; // 第二个手指坐标x暂存</span><br><span class="line">          this.sy2 = sCurrentY; // 第二个手指坐标y暂存</span><br><span class="line">      &#125; else &#123; // 单指move情况下</span><br><span class="line">          if (this.x2 !== null) &#123; // 第一次移动this.x2=null的,第二次之后才为true</span><br><span class="line">              evt.deltaX = currentX - this.x2; // x方向两次move事件的差值</span><br><span class="line">              evt.deltaY = currentY - this.y2; // y方向两次move事件的差值</span><br><span class="line"></span><br><span class="line">              //move事件中添加对当前触摸点到初始触摸点的判断，</span><br><span class="line">              //如果曾经大于过某个距离(比如10),就认为是移动到某个地方又移回来，应该不再触发tap事件才对。</span><br><span class="line">              var movedX = Math.abs(this.x1 - this.x2),</span><br><span class="line">                  movedY = Math.abs(this.y1 - this.y2);</span><br><span class="line"></span><br><span class="line">              if(movedX &gt; 10 || movedY &gt; 10)&#123;</span><br><span class="line">                  this._preventTap = true;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125; else &#123; // 第一次移动都为0</span><br><span class="line">              evt.deltaX = 0;</span><br><span class="line">              evt.deltaY = 0;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          this.pressMove.dispatch(evt, this.element); // 一个手指移动的触发回调</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.touchMove.dispatch(evt, this.element); // 有移动就触发touchMove事件回调</span><br><span class="line"></span><br><span class="line">      this._cancelLongTap(); // 有移动事件了，清除长按的事件回调</span><br><span class="line">      this.x2 = currentX; // 将当前第一个手指的坐标x复制给this.x2</span><br><span class="line">      this.y2 = currentY; // 将当前第一个手指的坐标y复制给this.y2</span><br><span class="line">      </span><br><span class="line">      if (len &gt; 1) &#123; // 两个以上手指，阻止浏览器默认事件</span><br><span class="line">          evt.preventDefault();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  end: function (evt) &#123;</span><br><span class="line">      if (!evt.changedTouches) return; // end事件触发时，changedTouches为空，则返回</span><br><span class="line">      this._cancelLongTap(); // 取消长按的回调函数</span><br><span class="line">      var self = this; // this暂存在bianliangself</span><br><span class="line">      if (evt.touches.length &lt; 2) &#123; // 目前屏幕上留下的手指0或者1个</span><br><span class="line">          this.multipointEnd.dispatch(evt, this.element); // 调用多指触摸的结束回调</span><br><span class="line">          this.sx2 = this.sy2 = null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //swipe</span><br><span class="line">      // this.x2或this.y2有值说明有在屏幕上移动，并且计算移动后离开屏幕时的坐标与this.x1手指刚触摸屏幕时的坐标差值大于30，可以出发swipe事件回调</span><br><span class="line">      if ((this.x2 &amp;&amp; Math.abs(this.x1 - this.x2) &gt; 30) ||</span><br><span class="line">          (this.y2 &amp;&amp; Math.abs(this.y1 - this.y2) &gt; 30)) &#123;</span><br><span class="line">          // 获取滑动的方向  </span><br><span class="line">          evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2);</span><br><span class="line">          this.swipeTimeout = setTimeout(function () &#123; // 触发swipe回调函数，加入宏任务队列</span><br><span class="line">              self.swipe.dispatch(evt, self.element);</span><br><span class="line"></span><br><span class="line">          &#125;, 0)</span><br><span class="line">      &#125; else &#123; // 这里说明不是swipe事件，只是点击事件</span><br><span class="line">          this.tapTimeout = setTimeout(function () &#123; // 点击定时器</span><br><span class="line">              if(!self._preventTap)&#123; // 长按事件函数没有执行</span><br><span class="line">                  self.tap.dispatch(evt, self.element); // 执行tap回调</span><br><span class="line">              &#125;</span><br><span class="line">              // trigger double tap immediately</span><br><span class="line">              if (self.isDoubleTap) &#123; // 如果是双击的话</span><br><span class="line">                  self.doubleTap.dispatch(evt, self.element); // 执行双击事件回调</span><br><span class="line">                  self.isDoubleTap = false; // 执行之后设置双击标识为假</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;, 0)</span><br><span class="line"></span><br><span class="line">          if (!self.isDoubleTap) &#123; // 如果不是双击操作</span><br><span class="line">              self.singleTapTimeout = setTimeout(function () &#123; // 250ms后执行singleTap事件回调</span><br><span class="line">                  self.singleTap.dispatch(evt, self.element);</span><br><span class="line">              &#125;, 250);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      this.touchEnd.dispatch(evt, this.element); // 手指离开都会触发touchEnd事件回调</span><br><span class="line">      // 手指离开后将一些属性重置</span><br><span class="line">      this.preV.x = 0;</span><br><span class="line">      this.preV.y = 0;</span><br><span class="line">      this.zoom = 1;</span><br><span class="line">      this.pinchStartLen = null;</span><br><span class="line">      this.x1 = this.x2 = this.y1 = this.y2 = null;</span><br><span class="line">  &#125;,</span><br><span class="line">  cancelAll: function () &#123;</span><br><span class="line">      this._preventTap = true; // 阻止tap事件</span><br><span class="line">      clearTimeout(this.singleTapTimeout); // 清除singleTapTimeout定时器</span><br><span class="line">      clearTimeout(this.tapTimeout); // 清除tapTimeout定时器</span><br><span class="line">      clearTimeout(this.longTapTimeout); // 清除longTapTimeout定时器</span><br><span class="line">      clearTimeout(this.swipeTimeout); // 清除swipeTimeout定时器</span><br><span class="line">  &#125;,</span><br><span class="line">  cancel: function (evt) &#123; // cancel事件</span><br><span class="line">      this.cancelAll()</span><br><span class="line">      this.touchCancel.dispatch(evt, this.element); // 触发touchCancel回调</span><br><span class="line">  &#125;,</span><br><span class="line">  _cancelLongTap: function () &#123; // 清除longTapTimeout定时器函数</span><br><span class="line">      clearTimeout(this.longTapTimeout);</span><br><span class="line">  &#125;,</span><br><span class="line">  _cancelSingleTap: function () &#123; // 清除singleTapTimeout定时器函数</span><br><span class="line">      clearTimeout(this.singleTapTimeout);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 计算swipe的方向函数</span><br><span class="line">  _swipeDirection: function (x1, x2, y1, y2) &#123;</span><br><span class="line">      return Math.abs(x1 - x2) &gt;= Math.abs(y1 - y2) ? (x1 - x2 &gt; 0 ? &apos;Left&apos; : &apos;Right&apos;) : (y1 - y2 &gt; 0 ? &apos;Up&apos; : &apos;Down&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 使用实例给事件添加回调函数</span><br><span class="line">  on: function(evt, handler) &#123;</span><br><span class="line">      if(this[evt]) &#123;</span><br><span class="line">          this[evt].add(handler);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 使用实例给事件删除回调函数</span><br><span class="line">  off: function(evt, handler) &#123;</span><br><span class="line">      if(this[evt]) &#123;</span><br><span class="line">          this[evt].del(handler);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 实例销毁函数</span><br><span class="line">  destroy: function() &#123;</span><br><span class="line">      if(this.singleTapTimeout) clearTimeout(this.singleTapTimeout);</span><br><span class="line">      if(this.tapTimeout) clearTimeout(this.tapTimeout);</span><br><span class="line">      if(this.longTapTimeout) clearTimeout(this.longTapTimeout);</span><br><span class="line">      if(this.swipeTimeout) clearTimeout(this.swipeTimeout);</span><br><span class="line"></span><br><span class="line">      this.element.removeEventListener(&quot;touchstart&quot;, this.start);</span><br><span class="line">      this.element.removeEventListener(&quot;touchmove&quot;, this.move);</span><br><span class="line">      this.element.removeEventListener(&quot;touchend&quot;, this.end);</span><br><span class="line">      this.element.removeEventListener(&quot;touchcancel&quot;, this.cancel);</span><br><span class="line"></span><br><span class="line">      this.rotate.del();</span><br><span class="line">      this.touchStart.del();</span><br><span class="line">      this.multipointStart.del();</span><br><span class="line">      this.multipointEnd.del();</span><br><span class="line">      this.pinch.del();</span><br><span class="line">      this.swipe.del();</span><br><span class="line">      this.tap.del();</span><br><span class="line">      this.doubleTap.del();</span><br><span class="line">      this.longTap.del();</span><br><span class="line">      this.singleTap.del();</span><br><span class="line">      this.pressMove.del();</span><br><span class="line">      this.twoFingerPressMove.del()</span><br><span class="line">      this.touchMove.del();</span><br><span class="line">      this.touchEnd.del();</span><br><span class="line">      this.touchCancel.del();</span><br><span class="line"></span><br><span class="line">      this.preV = this.pinchStartLen = this.zoom = this.isDoubleTap = this.delta = this.last = this.now = this.tapTimeout = this.singleTapTimeout = this.longTapTimeout = this.swipeTimeout = this.x1 = this.x2 = this.y1 = this.y2 = this.preTapPosition = this.rotate = this.touchStart = this.multipointStart = this.multipointEnd = this.pinch = this.swipe = this.tap = this.doubleTap = this.longTap = this.singleTap = this.pressMove = this.touchMove = this.touchEnd = this.touchCancel = this.twoFingerPressMove = null;</span><br><span class="line"></span><br><span class="line">      window.removeEventListener(&apos;scroll&apos;, this._cancelAllHandler);</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 暴露给外部使用</span><br><span class="line">  if (typeof module !== &apos;undefined&apos; &amp;&amp; typeof exports === &apos;object&apos;) &#123;</span><br><span class="line">    module.exports = AlloyFinger;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      window.AlloyFinger = AlloyFinger;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动端手势库AlloyFinger分析&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="移动端" scheme="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>手写call,apply,bind函数</title>
    <link href="/2020/03/25/%E6%89%8B%E5%86%99call-apply-bind%E5%87%BD%E6%95%B0/"/>
    <id>/2020/03/25/手写call-apply-bind函数/</id>
    <published>2020-03-25T06:17:43.000Z</published>
    <updated>2020-03-25T07:01:19.519Z</updated>
    
    <content type="html"><![CDATA[<p>手写call,apply,bind函数<br><a id="more"></a></p><h1 id="手写call-apply-bind函数"><a href="#手写call-apply-bind函数" class="headerlink" title="手写call,apply,bind函数"></a>手写call,apply,bind函数</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">    context = context || window;</span><br><span class="line">    var arg = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var result = context.fn(...arg);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myCall(testObj, 1, 2, 3);</span><br></pre></td></tr></table></figure></p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function(context) &#123;</span><br><span class="line">    context = context || window;</span><br><span class="line">    var arg = arguments[1];</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var result = context.fn(...arg);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myApply(testObj, [1, 2, 3]);</span><br></pre></td></tr></table></figure></p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function(context) &#123;</span><br><span class="line">  if (typeof this !== &apos;function&apos;) &#123;</span><br><span class="line">    throw new TypeError(&apos;Error&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  let _this = this</span><br><span class="line">  let args = [...arguments].slice(1)</span><br><span class="line">  return function F() &#123;</span><br><span class="line">    // 判断是否被当做构造函数使用</span><br><span class="line">    if (this instanceof F) &#123;</span><br><span class="line">      return _this.apply(this, args.concat([...arguments]))</span><br><span class="line">    &#125;</span><br><span class="line">    return _this.apply(context, args.concat([...arguments]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myBind(testObj, 1)(2, 3);</span><br></pre></td></tr></table></figure></p><p>以上就是我们常用的call，apply，bind函数的手写实现，但是，用到了es6的[…arg]结构语法，下面只写一个call实现的es5版本。</p><h2 id="call-es5版"><a href="#call-es5版" class="headerlink" title="call es5版"></a>call es5版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">    context = context || window;</span><br><span class="line">    var arg = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var fnStr = `context.fn(`;</span><br><span class="line">    for(var i=0, len=arg.length; i&lt;len; i++) &#123;</span><br><span class="line">        if(i === (len-1)) &#123;</span><br><span class="line">            fnStr += arg[i];    </span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            fnStr += arg[i] + &apos;,&apos;;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fnStr += &apos;)&apos;;</span><br><span class="line">    console.log(fnStr);</span><br><span class="line">    var result = eval(fnStr);</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var testObj = &#123;</span><br><span class="line">    name: 123</span><br><span class="line">&#125;</span><br><span class="line">function testFn(a,b,c) &#123;</span><br><span class="line">    console.log(this, a, b, c);</span><br><span class="line">    return 555;</span><br><span class="line">&#125;</span><br><span class="line">testFn.myCall(testObj, 1, 2, 3);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手写call,apply,bind函数&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>手写Promise</title>
    <link href="/2020/03/20/%E6%89%8B%E5%86%99Promise/"/>
    <id>/2020/03/20/手写Promise/</id>
    <published>2020-03-20T05:30:12.000Z</published>
    <updated>2020-03-20T07:20:42.907Z</updated>
    
    <content type="html"><![CDATA[<p>模拟一个Promise功能<br><a id="more"></a></p><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><p>现在的异步基本上都是用Promise来实现的，用起来很方便，但是，Promise是怎么实现的呢，它的then回调是怎么工作的，带着这些疑问，决定自己实现一个Promise。<br>早在2年前，其实我就实现过一个Promise，不过那个原理比较笨，还用到了定时器循环，后来陆续看了些其他人的写法，还是有点没绕明白，这两天又看了向军老师的实现方式，觉得很好，自己也实现一下。<br>主要的难以理解的地方是then函数的写法，这个地方明白了整个Promise也就理解了。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">class MyPromise &#123;</span><br><span class="line">  // 等待状态</span><br><span class="line">  static PENDING = &quot;pending&quot;;</span><br><span class="line">  // 成功状态</span><br><span class="line">  static FULFILLED = &quot;fulfilled&quot;;</span><br><span class="line">  // 拒绝状态</span><br><span class="line">  static REJECTED = &quot;rejected&quot;;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    // 默认状态是等待</span><br><span class="line">    this.status = MyPromise.PENDING;</span><br><span class="line">    // 成功值</span><br><span class="line">    this.value = null;</span><br><span class="line">    // 拒绝值</span><br><span class="line">    this.reason = null;</span><br><span class="line">    // then的回调数组</span><br><span class="line">    this.callbacks = [];</span><br><span class="line">    try &#123;</span><br><span class="line">      executor(this.resolve.bind(this), this.reject.bind(this));</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      this.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 成功调用函数</span><br><span class="line">  resolve(value) &#123;</span><br><span class="line">    if(this.status === MyPromise.PENDING) &#123;</span><br><span class="line">      this.value = value;</span><br><span class="line">      this.status = MyPromise.FULFILLED;</span><br><span class="line">      setTimeout(()=&gt; &#123;</span><br><span class="line">        this.callbacks.forEach(item=&gt; &#123;</span><br><span class="line">          item.onFulfilled(this.value);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 拒绝调用函数</span><br><span class="line">  reject(reason) &#123;</span><br><span class="line">    if(this.status === MyPromise.PENDING) &#123;</span><br><span class="line">      this.reason = reason;</span><br><span class="line">      this.status = MyPromise.REJECTED;</span><br><span class="line">      setTimeout(()=&gt; &#123;</span><br><span class="line">        this.callbacks.forEach(item=&gt; &#123;</span><br><span class="line">          item.onRejected(this.reason);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // then函数</span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    if (typeof onFulfilled != &quot;function&quot;) &#123;</span><br><span class="line">      onFulfilled = () =&gt; this.value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (typeof onRejected != &quot;function&quot;) &#123;</span><br><span class="line">      onRejected = () =&gt; this.reason;</span><br><span class="line">    &#125;</span><br><span class="line">    // 链式调用，返回一个MyPromise</span><br><span class="line">    const p = new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      if(this.status === MyPromise.PENDING) &#123;</span><br><span class="line">        this.callbacks.push(&#123;</span><br><span class="line">          onFulfilled: (value)=&gt; &#123;</span><br><span class="line">            let result = onFulfilled(value);</span><br><span class="line">            if(result instanceof MyPromise) &#123;</span><br><span class="line">              result.then(resolve, reject);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">              resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected: (value)=&gt; &#123;</span><br><span class="line">            let result = onRejected(value);</span><br><span class="line">            if(result instanceof MyPromise) &#123;</span><br><span class="line">              result.then(resolve, reject);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">              resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      if(this.status === MyPromise.FULFILLED) &#123;</span><br><span class="line">        setTimeout(()=&gt; &#123;</span><br><span class="line">          let result = onFulfilled(this.value);</span><br><span class="line">          if(result instanceof MyPromise) &#123;</span><br><span class="line">            result.then(resolve, reject);</span><br><span class="line">          &#125;else &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      if(this.status === MyPromise.REJECTED) &#123;</span><br><span class="line">        setTimeout(()=&gt; &#123;</span><br><span class="line">          let result = onRejected(this.reason);</span><br><span class="line">          if(result instanceof MyPromise) &#123;</span><br><span class="line">            result.then(resolve, reject);</span><br><span class="line">          &#125;else &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.resolve方法</span><br><span class="line">  static resolve(value) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      if(value instanceof MyPromise) &#123;</span><br><span class="line">        value.then(resolve, reject);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.reject方法</span><br><span class="line">  static reject(reason) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.all方法</span><br><span class="line">  static all(promises) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      let values = [];</span><br><span class="line">      promises.forEach(item =&gt; &#123;</span><br><span class="line">        item.then(</span><br><span class="line">          value=&gt; &#123;</span><br><span class="line">            values.push(value);</span><br><span class="line">            if(values.length === promises.length) &#123;</span><br><span class="line">              resolve(values);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          reason=&gt; &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // MyPromise.race方法</span><br><span class="line">  static race(promises) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject)=&gt; &#123;</span><br><span class="line">      promises.forEach(item =&gt; &#123;</span><br><span class="line">        item.then(</span><br><span class="line">          value=&gt; &#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">          &#125;,</span><br><span class="line">          reason=&gt; &#123;</span><br><span class="line">            reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>demo代码<a href="https://github.com/jinux7/study-collections/tree/master/%E6%89%8B%E5%86%99promise" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模拟一个Promise功能&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>nodejs环境变量NODE_ENV</title>
    <link href="/2020/03/17/nodejs%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FNODE-ENV/"/>
    <id>/2020/03/17/nodejs环境变量NODE-ENV/</id>
    <published>2020-03-17T07:20:52.000Z</published>
    <updated>2020-03-17T08:14:52.457Z</updated>
    
    <content type="html"><![CDATA[<p>nodejs环境变量NODE_ENV的设置和获取<br><a id="more"></a></p><h1 id="nodejs环境变量NODE-ENV"><a href="#nodejs环境变量NODE-ENV" class="headerlink" title="nodejs环境变量NODE_ENV"></a>nodejs环境变量NODE_ENV</h1><p>我们在使用webpack打包的时候，会根据环境变量的不同做各种操作，那么，环境变量是如何设置和获取的呢？<br>首先说一下，在命令行中设置的环境变量是临时的，当命令行关闭后就没有了，要想持久化的设置环境变量，只能到我的电脑，属性，高级，环境变量里设置。</p><p>首先，创建一个app.js的文件，内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.env.NODE_ENV);</span><br></pre></td></tr></table></figure></p><p>我们把环境变量打印出来看看。<br>在命令行下(window系统的cmd可以，powershell和git bash不行)，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set NODE_ENV=pro &amp;&amp; node app.js</span><br></pre></td></tr></table></figure></p><p>打印出<code>pro</code><br>如果想在powershell和git bash都可以使用，那就得利用npm，在package.json中的scripts里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;pro&quot;: &quot;set NODE_ENV=pro &amp;&amp; node app.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>利用npm可以获取NODE_ENV的值。<br>这种方法的不足是，<code>set NODE_ENV=pro</code>是window的方式，而linux和ios是<code>export NODE_ENV=&#39;pro&#39;</code>,为了一套命令的兼容性，<br>我们可以使用<code>cross-env</code>这个nodejs模块，使用方法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;app.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;cross-env NODE_ENV=dev node app.js&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>好了，我们已经可以获取NODE_ENV环境变量了。<br>再介绍一个可以获取命令行参数的方便方法，<code>process.env.npm_config_argv</code><br>看名字就知道，只能在npm命令下使用，我们来看看具体使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.env.npm_config_argv);</span><br></pre></td></tr></table></figure></p><p>当我们执行<code>npm run dev</code><br>打印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;remain&quot;:[],&quot;cooked&quot;:[&quot;run&quot;,&quot;dev&quot;],&quot;original&quot;:[&quot;run&quot;,&quot;dev&quot;]&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以分析是dev还是pro来处理不同操作。<br>其实，我们想做的莫非就是利用命令行中不同的参数做不同的操作而已，nodejs有一个<code>process.argv</code>属性，可以获取命令行下的参数，来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(process.argv);</span><br></pre></td></tr></table></figure></p><p>我们在命令行下执行：<code>node app.js dev pro</code>。<br>打印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ &apos;C:\\Program Files\\nodejs\\node.exe&apos;,</span><br><span class="line">  &apos;C:\\Jinux\\test\\nodejs-env\\app.js&apos;,</span><br><span class="line">  &apos;dev&apos;,</span><br><span class="line">  &apos;pro&apos; ]</span><br></pre></td></tr></table></figure></p><p>我们还是可以根据命令行下的参数做不同的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodejs环境变量NODE_ENV的设置和获取&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="/categories/nodejs/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>iPhoneX适配</title>
    <link href="/2020/03/13/iPhoneX%E9%80%82%E9%85%8D/"/>
    <id>/2020/03/13/iPhoneX适配/</id>
    <published>2020-03-13T06:24:28.000Z</published>
    <updated>2020-03-13T06:44:07.611Z</updated>
    
    <content type="html"><![CDATA[<p>h5在iPhoneX中的页面兼容处理<br><a id="more"></a></p><h1 id="iPhoneX适配"><a href="#iPhoneX适配" class="headerlink" title="iPhoneX适配"></a>iPhoneX适配</h1><h2 id="基础设备信息"><a href="#基础设备信息" class="headerlink" title="基础设备信息"></a>基础设备信息</h2><p>首先在了解iPhoneX适配之前，需要了解关于iPhone设备的一些基础</p><h3 id="关于iPhone的一些基础参数"><a href="#关于iPhone的一些基础参数" class="headerlink" title="关于iPhone的一些基础参数"></a>关于iPhone的一些基础参数</h3><p><img src="/2020/03/13/iPhoneX适配/1.webp" alt="img"></p><h3 id="iPhoneX设备信息"><a href="#iPhoneX设备信息" class="headerlink" title="iPhoneX设备信息"></a>iPhoneX设备信息</h3><p>iPhoneX屏幕组成：上部齐刘海sensor housing（44pt） + 安全区域safe area + 底部手势区域Home Indicator（34pt）<br>safe area（安全区域）<br><img src="/2020/03/13/iPhoneX适配/2.webp" alt="img"><br>安全区域以外的是上部“齐刘海” 和 下部“手势区域”，一般情况下，我们都会在安全区域（safe area）中进行页面的编写；</p><h2 id="iPhoneX适配-1"><a href="#iPhoneX适配-1" class="headerlink" title="iPhoneX适配"></a>iPhoneX适配</h2><h3 id="适配方案viewport-fit"><a href="#适配方案viewport-fit" class="headerlink" title="适配方案viewport-fit"></a>适配方案viewport-fit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover&quot;&gt;</span><br></pre></td></tr></table></figure><p>viewport-fit有两个值，contain和 cover<br>默认是contain，页面内容显示在safe area中（不包括上部的齐刘海和下部的手势区域）<br>cover值：页面内容充满屏幕</p><h3 id="适配方案css-constant"><a href="#适配方案css-constant" class="headerlink" title="适配方案css constant()"></a>适配方案css constant()</h3><p>css constant()<br>有四个值：<code>safe-area-inset-top , safe-area-inset-left , safe-area-inset-right , safe-area-inset-bottom</code><br>1)当viewport-fit:contain，上面这个四个值无效<br>2)当viewport-fit:cover，这四个值需要设置，页面才会显示在安全区域中，设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    padding-top: constant(safe-area-inset-top);   //为导航栏+状态栏的高度 88px            </span><br><span class="line">    padding-left: constant(safe-area-inset-left);   //如果未竖屏时为0                </span><br><span class="line">    padding-right: constant(safe-area-inset-right); //如果未竖屏时为0                </span><br><span class="line">    padding-bottom: constant(safe-area-inset-bottom);//为底下圆弧的高度 34px       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="适配方案媒体查询"><a href="#适配方案媒体查询" class="headerlink" title="适配方案媒体查询"></a>适配方案媒体查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media only screen and (device-width: 385px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)&#123;</span><br><span class="line">  // iphoneX css部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="viewport-fit-contain"><a href="#viewport-fit-contain" class="headerlink" title="viewport-fit:contain"></a>viewport-fit:contain</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=contain&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="viewpoer-fit-cover-css-canstant"><a href="#viewpoer-fit-cover-css-canstant" class="headerlink" title="viewpoer-fit: cover + css canstant()"></a>viewpoer-fit: cover + css canstant()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  padding-top: constant(safe-area-inset-top);   //为导航栏+状态栏的高度 88px            </span><br><span class="line">  padding-left: constant(safe-area-inset-left);   //如果未竖屏时为0                </span><br><span class="line">  padding-right: constant(safe-area-inset-right); //如果未竖屏时为0                </span><br><span class="line">  padding-bottom: constant(safe-area-inset-bottom);//为底下圆弧的高度 34px       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="css的媒体查询"><a href="#css的媒体查询" class="headerlink" title="css的媒体查询"></a>css的媒体查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media only screen and (device-width: 385px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3)&#123;</span><br><span class="line">  // iphoneX css部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;h5在iPhoneX中的页面兼容处理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="移动端" scheme="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="兼容性" scheme="/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>generator自动运行器</title>
    <link href="/2020/03/12/generator%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%E5%99%A8/"/>
    <id>/2020/03/12/generator自动运行器/</id>
    <published>2020-03-12T07:08:06.000Z</published>
    <updated>2020-03-12T07:34:13.762Z</updated>
    
    <content type="html"><![CDATA[<p>手写一个generator自动运行器<br><a id="more"></a></p><h1 id="generator自动运行器"><a href="#generator自动运行器" class="headerlink" title="generator自动运行器"></a>generator自动运行器</h1><p>generator函数是es6新出的功能，之后又推出了async函数，操作异步真的是超级简单。我觉得我们在实际项目中使用generator的机会非常少，即使使用，一般也会依赖co这样的库来方便的使用generator。<br>但是我却想研究一下generator，所以写了一个generator不用手动的调用next函数，而是自动的调用。</p><h2 id="generator手动next代码"><a href="#generator手动next代码" class="headerlink" title="generator手动next代码"></a>generator手动next代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">var p1 = function() &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(1);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+2);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+3);</span><br><span class="line">      &#125;, 1500);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p1callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第1个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第2个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第3个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function *gen() &#123;</span><br><span class="line">    var val_1 = yield p1();</span><br><span class="line">    var val_2 = yield p2(val_1);</span><br><span class="line">    var val_3 = yield p3(val_2);</span><br><span class="line">  &#125; </span><br><span class="line">  var g = gen();</span><br><span class="line">  window.gObj = null;</span><br><span class="line">  window.gObj_index = 0;</span><br><span class="line">  gObj = g.next();</span><br><span class="line">  gObj.value.then(function(res) &#123;</span><br><span class="line">    console.log(&apos;第1个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">    gObj = g.next(res);</span><br><span class="line">    gObj.value.then(function(res) &#123;</span><br><span class="line">      console.log(&apos;第2个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">      gObj = g.next(res);</span><br><span class="line">      gObj.value.then(function(res) &#123;</span><br><span class="line">        console.log(&apos;第3个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码，需要在generator函数里手动定义yield的表达式，之后在执行的时候需要手动的调用next函数，但是可以看出来，还是有嵌套的情况。</p><h2 id="generator自动运行代码"><a href="#generator自动运行代码" class="headerlink" title="generator自动运行代码"></a>generator自动运行代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// p1,p2,p3是3个Promise的执行函数</span><br><span class="line">  var p1 = function() &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(1);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+2);</span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3 = function(val) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">        resolve(val+3);</span><br><span class="line">      &#125;, 1500);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // p1callback,p2callback,p3callback对应着p1,p2,p3的回调</span><br><span class="line">  var p1callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第1个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p2callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第2个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  var p3callback = function(res) &#123;</span><br><span class="line">    console.log(&apos;第3个yield的callback啊-&gt;&apos;, res);</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * @desc generator的生成函数</span><br><span class="line">   * @param &#123; Array &#125; Promise的函数数组</span><br><span class="line">   * @retuen &#123; Function &#125; generator函数</span><br><span class="line">  */</span><br><span class="line">  function gen(arr) &#123;</span><br><span class="line">    var valArr = [];</span><br><span class="line">    return function *() &#123;</span><br><span class="line">      for(var i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line">        valArr[i] = yield arr[i](valArr[i-1]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * @desc 自动执行generator的next()的函数</span><br><span class="line">   * @param &#123; Function &#125; gen函数</span><br><span class="line">   * @param &#123; Array &#125; Promise函数对应的回调函数数组</span><br><span class="line">   * @param &#123; Any &#125; 向generator的next中传入的值</span><br><span class="line">  */</span><br><span class="line">  function co(gen, arr, res) &#123;</span><br><span class="line">    var g = gen();</span><br><span class="line">    var gObj = null;</span><br><span class="line">    var gObj_index = 0;</span><br><span class="line">    function innerCo(g, arr, res) &#123;</span><br><span class="line">      gObj = g.next(res);</span><br><span class="line">      if(gObj.done) return void 0;</span><br><span class="line">      gObj.value.then(function(res) &#123;</span><br><span class="line">        arr[gObj_index++](res);  </span><br><span class="line">        if(!gObj.done) &#123;</span><br><span class="line">          innerCo(g, arr, res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    innerCo(g, arr, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  // 执行co函数</span><br><span class="line">  co(gen([p1,p2,p3]), [p1callback, p2callback, p3callback], 0);</span><br></pre></td></tr></table></figure><p>可以看出来，最后只需要<code>co(gen([p1,p2,p3]), [p1callback, p2callback, p3callback], 0);</code>这样一行代码，省去了定义yield，省去了调用next。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>首先，我并没有去参考co这样的库的使用方法，如何使用都是自己想出来的。</li><li>目前代码只是超级简化版，我也是想验证一下我的想法而已，只有resolve的回调，并没写reject的回调。</li></ul><p>最后，<a href="https://github.com/jinux7/study-collections/tree/master/generator-co" target="_blank" rel="noopener">代码在这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手写一个generator自动运行器&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化之时间切片</title>
    <link href="/2020/03/12/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E6%97%B6%E9%97%B4%E5%88%87%E7%89%87/"/>
    <id>/2020/03/12/前端性能优化之时间切片/</id>
    <published>2020-03-12T06:12:08.000Z</published>
    <updated>2020-03-12T07:00:54.136Z</updated>
    
    <content type="html"><![CDATA[<p>前端性能优化之时间切片<br><a id="more"></a></p><h1 id="前端性能优化之时间切片"><a href="#前端性能优化之时间切片" class="headerlink" title="前端性能优化之时间切片"></a>前端性能优化之时间切片</h1><p>从用户的输入，再到显示器在视觉上给用户的输出，这一过程如果超过 100ms，那么用户会察觉到网页的卡顿，所以为了解决这个问题，每个任务不能超过 50ms，W3C 性能工作组在 LongTask 规范中也将超过 50ms 的任务定义为长任务。<br>所以为了避免长任务，一种方案是使用 Web Worker，将长任务放在 Worker 线程中执行，缺点是无法访问 DOM，而另一种方案是使用时间切片。</p><h2 id="什么是时间切片"><a href="#什么是时间切片" class="headerlink" title="什么是时间切片"></a>什么是时间切片</h2><p>时间切片的核心思想是：如果任务不能在 50 毫秒内执行完，那么为了不阻塞主线程，这个任务应该让出主线程的控制权，使浏览器可以处理其他任务。让出控制权意味着停止执行当前任务，让浏览器去执行其他任务，随后再回来继续执行没有执行完的任务。<br>所以时间切片的目的是不阻塞主线程，而实现目的的技术手段是将一个长任务拆分成很多个不超过 50ms 的小任务分散在宏任务队列中执行。<br><img src="/2020/03/12/前端性能优化之时间切片/1.png" alt="img"><br>上图可以看到主线程中有一个长任务，这个任务会阻塞主线程。使用时间切片将它切割成很多个小任务后，如下图所示。<br><img src="/2020/03/12/前端性能优化之时间切片/2.png" alt="img"><br>可以看到现在的主线程有很多密密麻麻的小任务，我们将它放大后如下图所示。<br><img src="/2020/03/12/前端性能优化之时间切片/3.png" alt="img"><br>可以看到每个小任务中间是有空隙的，代表着任务执行了一小段时间后，将让出主线程的控制权，让浏览器执行其他的任务。</p><blockquote><p>使用时间切片的缺点是，任务运行的总时间变长了，这是因为它每处理完一个小任务后，主线程会空闲出来，并且在下一个小任务开始处理之前有一小段延迟。但是为了避免卡死浏览器，这种取舍是很有必要的。</p></blockquote><h2 id="如何使用时间切片"><a href="#如何使用时间切片" class="headerlink" title="如何使用时间切片"></a>如何使用时间切片</h2><p>时间切片是一种概念，也可以理解为一种技术方案，它不是某个 API 的名字，也不是某个工具的名字。<br>事实上，时间切片充分利用了“异步”，在早期，可以使用定时器来实现，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = function() &#123;</span><br><span class="line">    someThing() // 执行了50毫秒</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        otherThing() // 执行了50毫秒</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码当按钮被点击时，本应执行 100 毫秒的任务现在被拆分成了两个 50 毫秒的任务。<br>在实际应用中，我们可以进行一些封装，封装后的使用效果类似下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = ts([someThing, otherThing], function() &#123;</span><br><span class="line">    console.log(&apos;done~&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当然，关于ts这个函数的 API 的设计并不是本文的重点，这里想说明的是，在早期可以利用定时器来实现“时间切片”。<br>ES6 带来了迭代器的概念，并提供了生成器 Generator 函数用来生成迭代器对象，虽然 Generator 函数最正统的用法是生成迭代器对象，但这不妨我们利用它的特性做一些其他的事情。<br>Generator 函数提供了yield关键字，这个关键字可以让函数暂停执行。然后通过迭代器对象的next方法让函数继续执行。</p><blockquote><p>对 Generator 函数不熟悉的同学，需要先学习 Generator 函数的用法。<br>利用这个特性，我们可以设计出更方便使用的时间切片，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = ts(function*() &#123;</span><br><span class="line">    someThing() // 执行了50毫秒</span><br><span class="line">    yield</span><br><span class="line">    otherThing() // 执行了50毫秒</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><p>可以看到，我们只需要使用yield这个关键字就可以将本应执行 100 毫秒的任务拆分成了两个 50 毫秒的任务。<br>我们甚至可以将 yield 关键字放在循环里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = ts(function*() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        someThing() // 执行了50毫秒</span><br><span class="line">        yield</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上面代码我们写了一个死循环，但依然不会阻塞主线程，浏览器也不会卡死。</p><h2 id="基于生成器的-ts-实现原理"><a href="#基于生成器的-ts-实现原理" class="headerlink" title="基于生成器的 ts 实现原理"></a>基于生成器的 ts 实现原理</h2><p>通过前面的例子，我们会发现基于 Generator 的时间切片非常好用，但其实 ts 函数的实现原理非常简单，一个最简单的 ts 函数只需要九行代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function ts(gen) &#123;</span><br><span class="line">    if (typeof gen === &apos;function&apos;) gen = gen()</span><br><span class="line">    if (!gen || typeof gen.next !== &apos;function&apos;) return</span><br><span class="line">    return function next() &#123;</span><br><span class="line">        const res = gen.next()</span><br><span class="line">        if (res.done) return</span><br><span class="line">        setTimeout(next)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码虽然全部只有 9 行，关键代码只有 3、4 行，但这几行代码充分利用了事件循环机制以及 Generator 函数的特性。</p><blockquote><p>创造出这样的代码我还是很开心的。</p></blockquote><p>上面代码核心思想是：通过yield关键字可以将任务暂停执行，从而让出主线程的控制权；通过定时器可以将“未完成的任务”重新放在任务队列中继续执行。</p><h2 id="避免把任务分解的过于零碎"><a href="#避免把任务分解的过于零碎" class="headerlink" title="避免把任务分解的过于零碎"></a>避免把任务分解的过于零碎</h2><p>使用yield来切割任务非常方便，但如果切割的粒度特别细，反而效率不高。假设我们的任务执行100ms，最好的方式是切割成两个执行50ms的任务，而不是切割成 100 个执行1ms的任务。假设被切割的任务之间的间隔为4ms，那么切割成 100 个执行1ms的任务的总执行时间为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 + 4) * 100 = 500ms</span><br></pre></td></tr></table></figure></p><p>如果切割成两个执行时间为50ms的任务，那么总执行时间为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(50 + 4) * 2 = 108ms</span><br></pre></td></tr></table></figure></p><p>可以看到，在不影响用户体验的情况下，下面的总执行时间要比前面的少了 4.6 倍。<br>保证切割的任务刚好接近50ms，可以在用户使用yield时自行评估，也可以在ts函数中根据任务的执行时间判断是否应该一次性执行多个任务。<br>我们将ts函数稍微改进一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function ts(gen) &#123;</span><br><span class="line">    if (typeof gen === &apos;function&apos;) gen = gen()</span><br><span class="line">    if (!gen || typeof gen.next !== &apos;function&apos;) return</span><br><span class="line">    return function next() &#123;</span><br><span class="line">        const start = performance.now()</span><br><span class="line">        let res = null</span><br><span class="line">        do &#123;</span><br><span class="line">            res = gen.next()</span><br><span class="line">        &#125; while (!res.done &amp;&amp; performance.now() - start &lt; 25)</span><br><span class="line"></span><br><span class="line">        if (res.done) return</span><br><span class="line">        setTimeout(next)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们测试下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ts(function*() &#123;</span><br><span class="line">    const start = performance.now()</span><br><span class="line">    while (performance.now() - start &lt; 1000) &#123;</span><br><span class="line">        console.log(11)</span><br><span class="line">        yield</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;done!&apos;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>这段代码在之前的版本中，在我的电脑上可以打印出 215 次 11，在后面的版本中可以打印出 6300 次 11，说明在总时间相同的情况下，可以执行更多的任务。<br>再看另一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ts(function*() &#123;</span><br><span class="line">    for (let i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        console.log(11)</span><br><span class="line">        yield</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;done!&apos;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>在我的电脑上，这段代码在之前的版本中，被切割成一万个小任务，总执行时间为 46秒，在之后的版本中，被切割成 52 个小任务，总执行时间为 1.5秒。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上代码出自于网络，这里感谢作者的付出，同时贴出作者的原创地址:<br><a href="https://ppt.baomitu.com/d/b267a4a3" target="_blank" rel="noopener">《让你的网页更丝滑》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端性能优化之时间切片&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>手写mockjs</title>
    <link href="/2020/03/10/%E6%89%8B%E5%86%99mockjs/"/>
    <id>/2020/03/10/手写mockjs/</id>
    <published>2020-03-10T03:32:31.000Z</published>
    <updated>2020-03-10T05:43:36.531Z</updated>
    
    <content type="html"><![CDATA[<p>简单的写一个mockjs<br><a id="more"></a></p><h1 id="手写mockjs"><a href="#手写mockjs" class="headerlink" title="手写mockjs"></a>手写mockjs</h1><p>在我们前端的开发中，mock数据是必须走的一环，我们可以完全脱离后端接口，等我们前端开发好了之后，再跟后台接口的无缝对接。<br>其实mock数据的方式有很多，比如写一些静态text文档，用nodejs写一个后台服务，都可以满足mock数据的需求。但是，最方便的莫过于使用mockjs工具库了，他可以自动的拦截ajax请求，返回配置好的mock数据。<br>我第一次这个库大概是2016年，感觉很方便，后来也想过它的实现原理是什么，不过当时没有想出来。最近在使用vue的ant pro时候，里面就使用了mockjs，于是准备自己写一个mockjs。<br>我并没有看mockjs的源码，不知道它是怎么实现的，我的想法是既然它可以拦截ajax的请求，那么肯定对原生的XMLHttpRequest做了什么处理，于是乎，我准备覆盖掉原生的XMLHttpRequest对象，这样使用ajax的时候new出来的对象是我自己写的构造函数，不就可以满足拦截ajax请求的目的了吗。<br>我只是实现了拦截ajax的初级功能，并没有深入，点到为止。<br>mockjs代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">// 将原生的XMLHttpRequest缓存起来</span><br><span class="line">window.XMLHttpRequestMock = window.XMLHttpRequest;</span><br><span class="line">// mock对象，用来存储ajax的path和返回的数据</span><br><span class="line">window.mock = &#123;</span><br><span class="line">  urlData: &#123;&#125;,</span><br><span class="line">  setPath: function(path, data) &#123;</span><br><span class="line">    this.urlData[path] = data;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">// 覆盖原生XMLHttpRequest的构造函数</span><br><span class="line">function XmlMock() &#123;</span><br><span class="line">  this.type = null;</span><br><span class="line">  this.url = null;</span><br><span class="line">  this.onreadystatechange = null;</span><br><span class="line">&#125;</span><br><span class="line">// open方法</span><br><span class="line">XmlMock.prototype.open = function(type, url) &#123;</span><br><span class="line">  this.type = type;</span><br><span class="line">  this.url = url;</span><br><span class="line">  this.readyState = 4;</span><br><span class="line">  this.status = 200</span><br><span class="line">&#125;</span><br><span class="line">// send方法，这里会判断，如果请求的path在mock.urlData中则返回设置好据的数，</span><br><span class="line">// 如果不在，则利用原生的XMLHttpRequest来进行ajax网络请求</span><br><span class="line">XmlMock.prototype.send = function(params) &#123;</span><br><span class="line">  var path = &apos;&apos;; </span><br><span class="line">  var _this = this; </span><br><span class="line">  for(var key in mock.urlData) &#123;</span><br><span class="line">    if((this.url).indexOf(key)&gt;-1) &#123;</span><br><span class="line">      path = key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if(path) &#123;</span><br><span class="line">    this.responseText = mock.urlData[path];</span><br><span class="line">    this.onreadystatechange(this);</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    var xhr = new XMLHttpRequestMock();</span><br><span class="line">    xhr.open(&apos;get&apos;, this.url, false);</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if(xhr.readyState===4&amp;&amp;xhr.status===200) &#123;</span><br><span class="line">        _this.responseText = xhr.responseText;</span><br><span class="line">        _this.onreadystatechange(_this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.XMLHttpRequest = XmlMock;</span><br></pre></td></tr></table></figure></p><p>html使用代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;./mock.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  mock.setPath(&apos;get/小明&apos;, &#123;name: &apos;小明&apos;&#125;);</span><br><span class="line">  mock.setPath(&apos;get/小红&apos;, &#123;name: &apos;小红&apos;&#125;);</span><br><span class="line"></span><br><span class="line">  fetchData(&apos;http://jinux.top/get/小明&apos;, function(res) &#123;</span><br><span class="line">    console.log(&apos;小明mock数据-&gt;&apos;, res);</span><br><span class="line">  &#125;);</span><br><span class="line">  fetchData(&apos;http://jinux.top/get/小红&apos;, function(res) &#123;</span><br><span class="line">    console.log(&apos;小红mock数据-&gt;&apos;, res);</span><br><span class="line">  &#125;);</span><br><span class="line">  // 测试真实的ajax数据，用的实际百度的一个链接</span><br><span class="line">  var testUrl = &apos;https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/protocol/https/home/js/nu_instant_search_baaa58d.js&apos;;</span><br><span class="line">  fetchData(testUrl, function(res) &#123;</span><br><span class="line">    console.log(&apos;百度的真是数据-&gt;&apos;, res);</span><br><span class="line">  &#125;);</span><br><span class="line">  // 封装的ajax请求方法</span><br><span class="line">  function fetchData(url, callback) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&apos;get&apos;, url, false);</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if(xhr.readyState===4&amp;&amp;xhr.status===200) &#123;</span><br><span class="line">        callback(xhr.responseText);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>最后，附上代码，<a href="https://github.com/jinux7/study-collections/tree/master/%E6%89%8B%E5%86%99mockjs" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的写一个mockjs&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="工具库" scheme="/tags/%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
    
      <category term="ajax" scheme="/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>wireshark抓包工具</title>
    <link href="/2020/03/09/wireshark%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    <id>/2020/03/09/wireshark抓包工具/</id>
    <published>2020-03-09T07:18:21.000Z</published>
    <updated>2020-03-09T08:11:46.624Z</updated>
    
    <content type="html"><![CDATA[<p>wireshark是一款非常厉害的网络抓包工具<br><a id="more"></a></p><h1 id="wireshark抓包工具"><a href="#wireshark抓包工具" class="headerlink" title="wireshark抓包工具"></a>wireshark抓包工具</h1><p>作为一个前端开发，讨论网络抓包有点不务正业，但是知道点还是有好处的。<br>我平时用到的抓包工具有wireshark和charles，charles使用起来简单些，抓取http请求比较直观，wireshark的功能就强大得多，各种网络协议都可以解析，具体的使用细节就不说了，简单的说一下tcp协议的三次握手和四次挥手在wireshark中被抓取的数据。<br>首先看一下tcp的三次握手和四次挥手图解过程<br>1.三次握手：<br><img src="/2020/03/09/wireshark抓包工具/1.png" alt="img"><br>2.四次挥手：<br><img src="/2020/03/09/wireshark抓包工具/2.png" alt="img"><br>3.最后，wireshark抓取的数据：<br><img src="/2020/03/09/wireshark抓包工具/3.png" alt="img"><br>可以看到，前3个tcp是握手过程，最后4个tcp是挥手过程，中间的TLS协议是加密协议，因为我抓取的是https协议，所以会有加密协议。<br>本想再贴一个http协议的抓取截屏，抓了几次太乱了，还有好多失败的包，不贴了，大同小异，大概了解过程就行了，有精力的话，继续深入研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;wireshark是一款非常厉害的网络抓包工具&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="网络基础" scheme="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试题" scheme="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>javascript严格模式</title>
    <link href="/2020/02/28/javascript%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <id>/2020/02/28/javascript严格模式/</id>
    <published>2020-02-28T07:05:50.000Z</published>
    <updated>2020-03-01T08:45:34.425Z</updated>
    
    <content type="html"><![CDATA[<p>js的严格模式和普通模式的区别<br><a id="more"></a></p><h1 id="javascript严格模式"><a href="#javascript严格模式" class="headerlink" title="javascript严格模式"></a>javascript严格模式</h1><p>随着javascript的不断发展，严格模式在开发中是必须使用的，他有什么好处呢？<br>严格模式消除了一些不确定的行为，并且对某些不安全的操作抛出异常。它有助于解析引擎，优化代码，提高执行速度，也为以后新标准的制定留出余地。下面将对严格模式做一个详细的介绍。</p><h2 id="1-启用严格模式"><a href="#1-启用严格模式" class="headerlink" title="1.启用严格模式"></a>1.启用严格模式</h2><p>要使一个javascript文件运行于严格模式，只需要在文件顶部添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br></pre></td></tr></table></figure></p><p>这行代码是一个编译指示，用以告知解析引擎以严格模式解析脚本。严格模式可以用于整个脚本或单个函数。在用于脚本文件时，”use strict”需放在所有其它语句前面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// whole-script strict mode syntax</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">var v = &quot;Hi! I&apos;m a strict mode script!&quot;;</span><br></pre></td></tr></table></figure></p><p>而用于函数时，需方在函数内第一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function strict() &#123;</span><br><span class="line">  // Function-level strict mode syntax</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  function nested() &#123;</span><br><span class="line">    return &quot;And so am I!&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &quot;Hi! I&apos;m a strict mode function@ &quot; + nested();</span><br><span class="line">&#125;</span><br><span class="line">function notStrict() &#123;</span><br><span class="line">  return &quot;I&apos;m not strict.&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-严格模式带来的变化"><a href="#2-严格模式带来的变化" class="headerlink" title="2.严格模式带来的变化"></a>2.严格模式带来的变化</h2><p>在语法和行为这两方面，严格模式都做了一些改变。这些变化主要分为以下几类。</p><ul><li>对错误抛出异常，而不是静默地忽略；</li><li>简化变量的使用，去掉引擎难以优化的语法功能；</li><li>简化eval和arguments的使用；</li><li>增加安全特性；</li><li>为javascript迎接新标准做准备；</li></ul><h3 id="1"><a href="#1" class="headerlink" title="1)"></a>1)</h3><p>对错误抛出异常，而不是静默的忽略。严格模式将过去那些能够被静默忽略的错误变成异常抛出，因为这类错误代表着代码目的的矛盾。不一致的代码也许在当时不会产生什么不良后果，但未来可能会引起严重问题。严格模式不会容忍这些错误，使得开发者能够立即发现并且解决。</p><h4 id="1-1"><a href="#1-1" class="headerlink" title="(1)"></a>(1)</h4><p>在正常模式下，对一个没有声明的变量赋值，会自动作用到全局对象上（node的global对象，浏览器的window对象）。严格模式禁止这种做法，以避免意外地修改全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;</span><br><span class="line">mistypedVaraible = 17; // ReferenceError</span><br></pre></td></tr></table></figure></p><p>上面的代码将会抛出类型为ReferenceError的异常</p><h4 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h4><p>在正常模式下，引擎会默认忽略对NaN赋值的语句，但在严格模式下，引擎会以抛异常的方式，立即向开发者反馈错误。类似的还有给一个指定为不可写的属性赋值，对只有取值函数getter的属性赋值，给一个不可扩展的对象增加属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;</span><br><span class="line">// Assignment to NaN</span><br><span class="line">NaN = &apos;a&apos;; // TypeError: Cannot assign to read noly property &apos;NaN&apos; of #&lt;Object&gt;</span><br><span class="line">// Assignment to a non-writable property</span><br><span class="line">var obj1 = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj1, &quot;x&quot;, &#123;</span><br><span class="line">  value: 42,</span><br><span class="line">  writable: false</span><br><span class="line">&#125;);</span><br><span class="line">obj1.x = 9; // throws a TypeError</span><br><span class="line">// Assignment to a getter-only property</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  get x() &#123;</span><br><span class="line">    return 18;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj2.x = 5; // throws a TypeError</span><br><span class="line">// Assignment to a new property on a non-extensible object</span><br><span class="line">var fixed = &#123;&#125;;</span><br><span class="line">Object.preventExtensions(fixed);</span><br><span class="line">fixed.newProp = &quot;ohai&quot;; // throws a TypeError</span><br></pre></td></tr></table></figure></p><h4 id="3"><a href="#3" class="headerlink" title="(3)"></a>(3)</h4><p>严格模式禁止删除一个声明为不可删除的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">delete Object.prototype; // throws a TypeError</span><br></pre></td></tr></table></figure></p><h4 id="4"><a href="#4" class="headerlink" title="(4)"></a>(4)</h4><p>严格模式禁止声明重名属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var o = &#123;</span><br><span class="line">  p: 1,</span><br><span class="line">  p: 2</span><br><span class="line">&#125;; // !!! syntax error</span><br></pre></td></tr></table></figure></p><h4 id="5"><a href="#5" class="headerlink" title="(5)"></a>(5)</h4><p>严格模式规定，函数的参数名必须唯一，否则抛出语法错误。在正常模式下，相同名称的参数，位置最靠后的会把前面的隐藏，但所有参数仍然可以借由arguments[i]访问，因此这种隐藏的意义不大，很可能写错了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, a, c) &#123; // syntax error</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  return a + b + c; // wrong if this code ran</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="6"><a href="#6" class="headerlink" title="(6)"></a>(6)</h4><p>八进制数的写法。ECMAScript 5 标准下的严格模式禁止八进制数，但在ECMAScript 6标准下，八进制数前面需要加0o。Node支持前面加0o的八进制数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">// Right</span><br><span class="line">var a = 0o10; // ES6: Octal</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">// 以下代码异常</span><br><span class="line">// SyntaxError</span><br><span class="line">var sum = 015 + // syntax error</span><br><span class="line">          197 + 142;</span><br></pre></td></tr></table></figure></p><h4 id="7"><a href="#7" class="headerlink" title="(7)"></a>(7)</h4><p>严格模式禁止为基本数据类型添加属性，以下操作非法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  false.true = &quot;&quot;; // TypeError</span><br><span class="line">  (14).sailing = &quot;home&quot;;  // TypeError</span><br><span class="line">  &quot;with&quot;.you = &quot;far away&quot;; // TypeError</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h3 id="2-1"><a href="#2-1" class="headerlink" title="2)"></a>2)</h3><p>简化变量的使用，去掉引擎难以优化的语法功能。</p><h4 id="1-2"><a href="#1-2" class="headerlink" title="(1)"></a>(1)</h4><p>严格模式禁止使用with。with的问题在于，其语句内部的变量名只有在运行的时候才能够被决定，这使得引擎在编译阶段难以生成高效的代码。因为with代码块中的名称即有可能代表语句内部的变量，也有可能是with表达式中的对象属性，还有可能位于代码块外，甚至是全局对象的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x = 18;</span><br><span class="line">with(obj) &#123; // syntax error</span><br><span class="line">  x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-2"><a href="#2-2" class="headerlink" title="(2)"></a>(2)</h4><p>严格模式下，eval有单独的作用域，不能够使用eval语句在它之外创建变量。正常模式下，语句<figure class="highlight plain"><figcaption><span>x;")```会为它所在的运行环境声明一个变量x，在严格模式下，x只在eval语句的内部有效。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">var x = 18;</span><br><span class="line">var evalX = eval(&quot;&apos;use strict&apos;; var x = 42; x&quot;);</span><br><span class="line">console.assert(x === 18);</span><br><span class="line">console.assert(evalX === 42);</span><br></pre></td></tr></table></figure></p><h4 id="3-1"><a href="#3-1" class="headerlink" title="(3)"></a>(3)</h4><p>严格模式禁止删除变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x;</span><br><span class="line">delete x;                  // syntax error</span><br><span class="line">eval(&quot;var y; delete y;&quot;);  // syntax error</span><br></pre></td></tr></table></figure></p><h3 id="3-2"><a href="#3-2" class="headerlink" title="3)"></a>3)</h3><p>简化eval和arguments的使用。严格模式将eval和arguments的一些怪异和奇特的用法做了限制，并倾向于将eval和arguments当作关键字处理。</p><h4 id="1-3"><a href="#1-3" class="headerlink" title="(1)"></a>(1)</h4><p>严格模式不允许对eval和arguments赋值。以下语句运行都会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">eval = 18;</span><br><span class="line">arguments++;</span><br><span class="line">++eval;</span><br><span class="line">var obj = &#123; set p(arguments) &#123; &#125; &#125;;</span><br><span class="line">var eval;</span><br><span class="line">try &#123; &#125; catch(arguments) &#123; &#125;</span><br><span class="line">function x(eval) &#123; &#125;</span><br><span class="line">function arguments() &#123; &#125;</span><br><span class="line">var y = function eval() &#123; &#125;;</span><br><span class="line">var f = new Function(&quot;arguments&quot;, &quot;&apos;use strict&apos;; return 18;&quot;);</span><br></pre></td></tr></table></figure></p><h4 id="2-3"><a href="#2-3" class="headerlink" title="(2)"></a>(2)</h4><p>在严格模式下，修改函数参数不会影响arguments，下面的示例代码能够正常运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f(a) &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  a = 42;</span><br><span class="line">  return [a, arguments[0]];</span><br><span class="line">&#125;</span><br><span class="line">var pair = f(18);</span><br><span class="line">console.assert(pair[0] === 42);</span><br><span class="line">console.assert(pair[1] === 18);</span><br></pre></td></tr></table></figure></p><h4 id="3-3"><a href="#3-3" class="headerlink" title="(3)"></a>(3)</h4><p>arguments.callee不能再使用了。正常模式下，arguments.callee返回正在执行的函数本身的引用。在严格模式下，这种用法被禁止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;</span><br><span class="line">var f = function() &#123;</span><br><span class="line">  return arguments.callee;</span><br><span class="line">&#125;</span><br><span class="line">f(); // throws a TypeError;</span><br></pre></td></tr></table></figure></p><h3 id="4-1"><a href="#4-1" class="headerlink" title="4)"></a>4)</h3><p>增加安全特性。在严格模式下，写出安全的代码变得更容易，引擎不会越俎代庖，除非使用者有意地这样做。</p><h4 id="1-4"><a href="#1-4" class="headerlink" title="(1)"></a>(1)</h4><p>在严格模式下，函数的上下文对象this可以是简单的值，并且避免了对全局对象的引用。在正常模式下，this只是一个对象，例如下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">f.call(true);</span><br></pre></td></tr></table></figure></p><p>运行结果为[Boolean: true]，引擎会自动地将简单类型打包为对应的对象。单严格模式不会做这样的转换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function f(a) &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">f.call(true);</span><br></pre></td></tr></table></figure></p><p>运行结果为true。<br>正常模式下，如果不指定this对象，或者指定为undefined或null，则this引用的是全局对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f(a) &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">f.call(null);</span><br></pre></td></tr></table></figure></p><p>上面的代码打印出全局的global对象。但在严格模式下，除非使用call或apply明确指定this为global对象，否则this为null或者undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function f(a) &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">f.call(null);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure></p><h4 id="2-4"><a href="#2-4" class="headerlink" title="(2)"></a>(2)</h4><p>严格模式禁止访问函数对象属性caller和arguments，这意味着不再可能遍历调用堆栈了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function outer() &#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line">function inner() &#123;</span><br><span class="line">  console.log(arguments.callee.caller);</span><br><span class="line">  // TypeError: &apos;caller&apos;, &apos;callee&apos;, and</span><br><span class="line">  // &apos;arguments&apos; properties may not be accessed</span><br><span class="line">  // on strict mode functions or the arguments</span><br><span class="line">  // objects for calls to them</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure></p><h3 id="5-1"><a href="#5-1" class="headerlink" title="5)"></a>5)</h3><p>保留关键字。严格模式将implements,interface,let,package,private,protected,public,static和yield作为保留字，用户代码不能以这些名称命名变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function package(protected) &#123; // SyntaxError</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  var implements;             // SyntaxError </span><br><span class="line">  interface;                  // SyntaxError</span><br><span class="line">  while(true) &#123;</span><br><span class="line">    break interface;          // SyntaxError</span><br><span class="line">  &#125;</span><br><span class="line">  function private() &#123; &#125;      // SyntaxError</span><br><span class="line">&#125;</span><br><span class="line">function fun(static) &#123;        // SyntaxError</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js的严格模式和普通模式的区别&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>前端异常处理</title>
    <link href="/2020/02/27/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>/2020/02/27/前端异常处理/</id>
    <published>2020-02-27T06:23:25.000Z</published>
    <updated>2020-02-27T14:52:05.707Z</updated>
    
    <content type="html"><![CDATA[<p>异常在前端的处理<br><a id="more"></a></p><h1 id="前端异常处理"><a href="#前端异常处理" class="headerlink" title="前端异常处理"></a>前端异常处理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。</p><ul><li>增强用户体验；</li><li>远程定位问题；</li><li>未雨绸缪，及早发现问题；</li><li>无法复线问题，尤其是移动端，机型，系统都是问题；</li><li>完善的前端方案，前端监控系统；</li></ul><p>对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p><p>对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：</p><ul><li>JS 语法错误、代码异常</li><li>AJAX 请求异常</li><li>静态资源加载异常</li><li>Promise 异常</li><li>Iframe 异常</li><li>跨域 Script error</li><li>崩溃和卡顿</li></ul><p>下面我会针对每种具体情况来说明如何处理这些异常。</p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><p>try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。<br>1.同步运行时错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  let name = &apos;jartto&apos;;</span><br><span class="line">  console.log(nam);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： ReferenceError: nam is not defined</span><br><span class="line">    at index.html:16</span><br></pre></td></tr></table></figure></p><p>2.不能捕获到具体的语法错误，只有一个语法错误提示。我们修改一下代码，删掉一个单引号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  let name = &apos;jartto;</span><br><span class="line">  console.log(nam);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line">不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。</span><br></pre></td></tr></table></figure></p><p>3.异步错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(nam);</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught ReferenceError: nam is not defined</span><br><span class="line">    at index.html:31</span><br></pre></td></tr></table></figure></p><p>可以看出，try-catch是捕获不到异步错误的，下面会介绍异步的错误如何捕获。</p><h3 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h3><p>当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。<br>1.同步错误和异步错误都可以捕获到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// message：错误信息（字符串）。</span><br><span class="line">// source：发生错误的脚本URL（字符串）</span><br><span class="line">// lineno：发生错误的行号（数字）</span><br><span class="line">// colno：发生错误的列号（数字）</span><br><span class="line">// error：Error对象（对象）</span><br><span class="line">window.onerror = function(message, source, lineno, colno, error) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">  return true; // 这里返回true，控制台就不会输出被捕获的那个错误自己抛出的异常提示，见下面截图。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/27/前端异常处理/1.png" alt="img"><br><img src="/2020/02/27/前端异常处理/2.png" alt="img"><br>2.再试试语法错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = function(message, source, lineno, colno, error) &#123;</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line">let name = &apos;Jartto</span><br></pre></td></tr></table></figure></p><p>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught SyntaxError: Invalid or unexpected token</span><br></pre></td></tr></table></figure></p><p>语法错误还是不能捕获<br>3.我们试试网络请求异常的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onerror = function(message, source, lineno, colno, error) &#123;</span><br><span class="line">    console.log(&apos;捕获到异常：&apos;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;img src=&quot;./jartto.png&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>不论是静态资源异常，或者接口异常，错误都无法捕获到。<br>补充一点：window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx，上面已经有提到过。<br>需要注意：</p><ul><li>onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；</li><li>onerror 无法捕获语法错误；<br>到这里基本就清晰了：在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。<h3 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h3>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的onerror() 处理函数。这些 error 事件不会向上冒泡到 window，所以我们需要在每一个元素节点上监听error事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var nImgs = document.querySelectorAll(&apos;img&apos;);</span><br><span class="line">  nImgs.forEach(item=&gt; &#123;</span><br><span class="line">    item.addEventListener(&apos;error&apos;, function(ev) &#123;</span><br><span class="line">      console.log(&apos;捕获到异常：&apos;, ev);</span><br><span class="line">    &#125;, false);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>上面是来捕获页面中所有的img元素标签出现的错误。<br>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： Event &#123;isTrusted: true, type: &quot;error&quot;, target: img#img, currentTarget: img#img, eventPhase: 2, …&#125;</span><br></pre></td></tr></table></figure></p><p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。<br>需要注意：</p><ul><li>不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。</li><li>需要注意避免 addEventListener 重复监听。</li></ul><h3 id="Promise-Catch"><a href="#Promise-Catch" class="headerlink" title="Promise Catch"></a>Promise Catch</h3><p>在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。<br>没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。<br>解决方案：为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;unhandledrejection&quot;, function(e)&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  console.log(&apos;捕获到异常：&apos;, e);</span><br><span class="line">  return true;</span><br><span class="line">&#125;);</span><br><span class="line">var pro = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  reject(&apos;错误&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// pro.catch(err=&gt; &#123;</span><br><span class="line">//   console.log(&apos;promise catch 捕获：&apos; + err);</span><br><span class="line">// &#125;);</span><br></pre></td></tr></table></figure></p><p>可以看到，如果忘记了catch的话，全局也可以捕获到Promise的错误。<br>控制台输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： PromiseRejectionEvent &#123;isTrusted: true, promise: Promise, reason: &quot;错误&quot;, type: &quot;unhandledrejection&quot;, target: Window, …&#125;</span><br></pre></td></tr></table></figure></p><p>所以，正如我们上面所说，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。<br>补充一点：如果去掉控制台的异常显示，需要加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure></p><h3 id="iframe-异常"><a href="#iframe-异常" class="headerlink" title="iframe 异常"></a>iframe 异常</h3><p>对于 iframe 的异常捕获，我们还得借力 window.onerror<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;./iframe.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.frames[0].onerror = function (message, source, lineno, colno, error) &#123;</span><br><span class="line">    console.log(&apos;捕获到 iframe 异常：&apos;,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="Script-error"><a href="#Script-error" class="headerlink" title="Script error"></a>Script error</h3><p>一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：<br>跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://jartto.wang/main.js&quot; crossorigin&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>或者动态去添加 js 脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const script = document.createElement(&apos;script&apos;);</span><br><span class="line">script.crossOrigin = &apos;anonymous&apos;;</span><br><span class="line">script.src = url;</span><br><span class="line">document.body.appendChild(script);</span><br></pre></td></tr></table></figure></p><p>特别注意，服务器端需要设置：Access-Control-Allow-Origin<br>此外，我们也可以试试这个-解决 Script Error 的另类思路：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const originAddEventListener = EventTarget.prototype.addEventListener;</span><br><span class="line">EventTarget.prototype.addEventListener = function (type, listener, options) &#123;</span><br><span class="line">  const wrappedListener = function (...args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return listener.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (err) &#123;</span><br><span class="line">      throw err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return originAddEventListener.call(this, type, wrappedListener, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单解释一下：<br>改写了 EventTarget 的 addEventListener 方法；对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(() =&gt; &#123;</span><br><span class="line">   const originAddEventListener = EventTarget.prototype.addEventListener;</span><br><span class="line">   EventTarget.prototype.addEventListener = function (type, listener, options) &#123;</span><br><span class="line">+    // 捕获添加事件时的堆栈</span><br><span class="line">+    const addStack = new Error(`Event ($&#123;type&#125;)`).stack;</span><br><span class="line">     const wrappedListener = function (...args) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">         return listener.apply(this, args);</span><br><span class="line">       &#125;</span><br><span class="line">       catch (err) &#123;</span><br><span class="line">+        // 异常发生时，扩展堆栈</span><br><span class="line">+        err.stack += &apos;\n&apos; + addStack;</span><br><span class="line">         throw err;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return originAddEventListener.call(this, type, wrappedListener, options);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure></p><h3 id="崩溃和卡顿"><a href="#崩溃和卡顿" class="headerlink" title="崩溃和卡顿"></a>崩溃和卡顿</h3><p>卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？<br>崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。<br>1.利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。不错的文章，推荐阅读：Logging Information on Browser Crashes。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;load&apos;, function () &#123;</span><br><span class="line">  sessionStorage.setItem(&apos;good_exit&apos;, &apos;pending&apos;);</span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">      sessionStorage.setItem(&apos;time_before_crash&apos;, new Date().toString());</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">window.addEventListener(&apos;beforeunload&apos;, function () &#123;</span><br><span class="line">  sessionStorage.setItem(&apos;good_exit&apos;, &apos;true&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">if(sessionStorage.getItem(&apos;good_exit&apos;) &amp;&amp;</span><br><span class="line">  sessionStorage.getItem(&apos;good_exit&apos;) !== &apos;true&apos;) &#123;</span><br><span class="line">  /*</span><br><span class="line">      insert crash logging code here</span><br><span class="line">  */</span><br><span class="line">  alert(&apos;Hey, welcome back from your crash, looks like you crashed on: &apos; + sessionStorage.getItem(&apos;time_before_crash&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.基于以下原因，我们可以使用 Service Worker 来实现网页崩溃的监控<br>Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。</p><h3 id="VUE-errorHandler"><a href="#VUE-errorHandler" class="headerlink" title="VUE errorHandler"></a>VUE errorHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = (err, vm, info) =&gt; &#123;</span><br><span class="line">  console.error(&apos;通过vue errorHandler捕获的错误&apos;);</span><br><span class="line">  console.error(err);</span><br><span class="line">  console.error(vm);</span><br><span class="line">  console.error(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="React-异常捕获"><a href="#React-异常捕获" class="headerlink" title="React 异常捕获"></a>React 异常捕获</h3><p>React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">  console.log(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外，我们可以了解一下：error boundary UI 的某部分引起的 JS 错误不应该破坏整个程序，为了帮 React 的使用者解决这个问题，React 16 介绍了一种关于错误边界（error boundary)的新观念。<br>需要注意的是：error boundaries 并不会捕捉下面这些错误。</p><ul><li>事件处理器</li><li>异步代码</li><li>服务端的渲染代码</li><li>在 error boundaries 区域内的错误<br>我们来举一个小例子，在下面这个 componentDIdCatch(error,info) 里的类会变成一个 error boundary<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; hasError: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    // Display fallback UI</span><br><span class="line">    this.setState(&#123; hasError: true &#125;);</span><br><span class="line">    // You can also log the error to an error reporting service</span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.hasError) &#123;</span><br><span class="line">      // You can render any custom fallback UI</span><br><span class="line">      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>然后我们像使用普通组件那样使用它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  &lt;MyWidget /&gt;</span><br><span class="line">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></table></figure></p><p>componentDidCatch() 方法像 JS 的 catch{} 模块一样工作，但是对于组件，只有 class 类型的组件(class component )可以成为一个 error boundaries 。<br>实际上，大多数情况下我们可以在整个程序中定义一个 error boundary 组件，之后就可以一直使用它了！</p><h3 id="错误上报"><a href="#错误上报" class="headerlink" title="错误上报"></a>错误上报</h3><p>通过 Ajax 发送数据 因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。<br>动态创建 img 标签的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function report(error) &#123;</span><br><span class="line">  let reportUrl = &apos;http://jartto.wang/report&apos;;</span><br><span class="line">  new Image().src = `$&#123;reportUrl&#125;?logs=$&#123;error&#125;`;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Reporter.send = function(data) &#123;</span><br><span class="line">  // 只采集 30%</span><br><span class="line">  if(Math.random() &lt; 0.3) &#123;</span><br><span class="line">    send(data)      // 上报错误信息</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到我们开头提出的那个问题，如何优雅的处理异常呢？</p><ul><li>可疑区域增加 Try-Catch</li><li>全局监控 JS 异常 window.onerror</li><li>全局监控静态资源异常 window.addEventListener</li><li>捕获没有 Catch 的 Promise 异常：unhandledrejection</li><li>VUE errorHandler 和 React componentDidCatch</li><li>监控网页崩溃：window 对象的 load 和 beforeunload</li><li>跨域 crossOrigin 解决</li></ul><p>其实很简单，正如上文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。</p><p>这篇文章部分代码<a href="https://github.com/jinux7/study-collections/tree/master/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" target="_blank" rel="noopener">点这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异常在前端的处理&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="/categories/javascript/"/>
    
    
      <category term="基础知识" scheme="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="web性能" scheme="/tags/web%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
</feed>
