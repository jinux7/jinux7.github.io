<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>前端常见的设计模式 | jinux</title>
  <meta name="description" content="前端 学习 javascript">
  <meta name="keywords" content>
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="alternate" href="/atom.xml" title="jinux">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前端常见的9种设计模式">
<meta name="keywords" content="基础知识,面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="前端常见的设计模式">
<meta property="og:url" content="/2020/11/19/前端常见的设计模式/index.html">
<meta property="og:site_name" content="jinux">
<meta property="og:description" content="前端常见的9种设计模式">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="/2020/11/19/前端常见的设计模式/1.jpg">
<meta property="og:updated_time" content="2024-01-11T07:00:59.259Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端常见的设计模式">
<meta name="twitter:description" content="前端常见的9种设计模式">
<meta name="twitter:image" content="/2020/11/19/前端常见的设计模式/1.jpg">

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="icon" href="/favicon.ico">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/node-waves/0.7.5/waves.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
</head>
</html>
<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script>
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				<!-- <i class="fa fa-home"></i> -->
				jinux
			</a>

				<div class='menu'>
					<ul class='h-list'>
						
							<li>
								<a class='flat-box nav-home' href='/'>
									<i class="fa fa-home"></i>
									主页
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-cube' href='/categories'>
									<i class="fa fa-cube"></i>
									导航
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-github' href='https://github.com/jinux7'>
									<i class="fa fa-github"></i>
									github
								</a>
							</li>
						
							<li>
								<a class='flat-box nav-archive' href='/archives'>
									<i class="fa fa-archive"></i>
									归档
								</a>
							</li>
						
					</ul>
					<div class='underline'></div>
				</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="Search" />
						<span class="icon"><i class="fa fa-search"></i></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a href='javascript:void(0)'><i class="fa fa-search flat-box"></i></span></a></li>
				
				<li class='s-menu'><a href='javascript:void(0)'><i class="fa fa-navicon flat-box"></i></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				xaoxuu
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><i class="fa fa-comments flat-box"></i></a></li>
				<li class='s-top'><a href='javascript:void(0)'><i class="fa fa-arrow-up flat-box"></i></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><i class="fa fa-list-ul flat-box"></i></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
        <div class="header">jinux</div>
		<nav>
			
				<a href="/" class="nav-home nav">
					<i class="fa fa-home"></i>
					主页
				</a>
			
				<a href="/categories" class="nav-cube nav">
					<i class="fa fa-cube"></i>
					导航
				</a>
			
				<a href="https://github.com/jinux7" class="nav-github nav">
					<i class="fa fa-github"></i>
					github
				</a>
			
				<a href="/archives" class="nav-archive nav">
					<i class="fa fa-archive"></i>
					归档
				</a>
			
		</nav>
	</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        <article id="post-前端常见的设计模式" class="post white-box article-type-post" itemscope itemprop="blogPost">
    <section class='meta'>
        <h1 class="title">
            
                前端常见的设计模式
            
        </h1>
        <time>
            2020-11-19 Thursday&nbsp;&nbsp;
            <i class="fa fa-eye" aria-hidden="true"></i>&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
        </time>
        
    
    <div class='cats'>
        <a href="/categories/javascript/">javascript</a>
    </div>


    </section>
    
        <section class="toc-wrapper">
            <div class="header"><i class="fa fa-list" aria-hidden="true"></i>&nbsp;&nbsp;目录</div>
            <div class='content'>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前端常见的设计模式"><span class="toc-number">1.</span> <span class="toc-text">前端常见的设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式类型"><span class="toc-number">1.1.</span> <span class="toc-text">设计模式类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#demo案例"><span class="toc-number">1.2.</span> <span class="toc-text">demo案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建型"><span class="toc-number">1.2.1.</span> <span class="toc-text">创建型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工厂模式"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型模式"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">原型模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构型"><span class="toc-number">1.2.2.</span> <span class="toc-text">结构型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#装饰器模式"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">装饰器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#适配器模式"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代理模式"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">代理模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#行为型"><span class="toc-number">1.2.3.</span> <span class="toc-text">行为型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#策略模式"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#观察者模式"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代器模式"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">迭代器模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
            </div>
        </section>
    

    <section class="article typo">

        <div class="article-entry" itemprop="articleBody">
            <p>前端常见的9种设计模式<br><a id="more"></a></p>
<h1 id="前端常见的设计模式"><a href="#前端常见的设计模式" class="headerlink" title="前端常见的设计模式"></a>前端常见的设计模式</h1><p>之前写过一篇比较全的设计模式<a href="/2019/06/24/javascript设计模式/">点击查阅</a>。<br>这篇文章主要写几个前端平时常用的设计模式案例。</p>
<h2 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h2><p><img src="/2020/11/19/前端常见的设计模式/1.jpg" alt="img"><br>通过图片的结构展示，可以快速的理解和记忆。</p>
<h2 id="demo案例"><a href="#demo案例" class="headerlink" title="demo案例"></a>demo案例</h2><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式根据抽象程度可分为三种，分别为简单工厂、工厂方法和抽象工厂。其核心在于将创建对象的过程封装其他，然后通过同一个接口创建新的对象。简单工厂模式又叫静态工厂方法，用来创建某一种产品对象的实例，用来创建单一对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (username, pwd, role) &#123;</span><br><span class="line">   <span class="keyword">this</span>.username = username;</span><br><span class="line">    <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    <span class="keyword">this</span>.role = role;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateRoleFactory</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> create (username, pwd, role) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Factory(username, pwd, role);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> admin = CreateRoleFactory.create(<span class="string">'张三'</span>, <span class="string">'222'</span>, <span class="string">'admin'</span>);</span><br></pre></td></tr></table></figure></p>
<p>在实际工作中，各用户角色所具备的能力是不同的，因此简单工厂是无法满足的，这时候就可以考虑使用工厂方法来代替。工厂方法的本意是将实际创建对象的工作推迟到子类中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span> (name, menuAuth) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">new</span>.target === User) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'User 不能被实例化'</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.menuAuth = menuAuth;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserFactory</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span> (...props) &#123;</span><br><span class="line">   <span class="keyword">super</span>(...props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> create (role) &#123;</span><br><span class="line">   <span class="keyword">const</span> roleCollection = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">     [<span class="string">'admin'</span>, () =&gt; <span class="keyword">new</span> UserFactory(<span class="string">'管理员'</span>, [<span class="string">'首页'</span>, <span class="string">'个人中心'</span>])],</span><br><span class="line">      [<span class="string">'user'</span>, () =&gt; <span class="keyword">new</span> UserFactory(<span class="string">'普通用户'</span>, [<span class="string">'首页'</span>])]</span><br><span class="line">    ])</span><br><span class="line">    <span class="keyword">return</span> roleCollection.get(role)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> admin = UserFactory.create(<span class="string">'admin'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(admin); <span class="comment">// &#123;name: "管理员", menuAuth: Array(2)&#125;</span></span><br><span class="line"><span class="keyword">const</span> user = UserFactory.create(<span class="string">'user'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user); <span class="comment">// &#123;name: "普通用户", menuAuth: Array(1)&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>随着业务形态的变化，一个用户可能在多个平台上同时存在，显然工厂方法也不再满足了，这时候就要用到抽象工厂。抽象工厂模式是对类的工厂抽象用来创建产品类簇，不负责创建某一类产品的实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (hospital) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === User) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象类不能实例化!'</span>);</span><br><span class="line">    <span class="keyword">this</span>.hospital = hospital;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 浙一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZheYiUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, departmentsAuth) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">'zheyi_hospital'</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.departmentsAuth = departmentsAuth;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 萧山医院</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoShanUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, departmentsAuth) &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">'xiaoshan_hospital'</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.departmentsAuth = departmentsAuth;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getAbstractUserFactory = <span class="function">(<span class="params">hospital</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (hospital) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'zheyi_hospital'</span>:</span><br><span class="line">      <span class="keyword">return</span> ZheYiUser;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'xiaoshan_hospital'</span>:</span><br><span class="line">      <span class="keyword">return</span> XiaoShanUser;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ZheYiUserClass = getAbstractUserFactory(<span class="string">'zheyi_hospital'</span>);</span><br><span class="line"><span class="keyword">const</span> XiaoShanUserClass = getAbstractUserFactory(<span class="string">'xiaoshan_hospital'</span>);</span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> ZheYiUserClass(<span class="string">'王医生'</span>, [<span class="string">'外科'</span>, <span class="string">'骨科'</span>, <span class="string">'神经外科'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(user1);</span><br><span class="line"><span class="keyword">const</span> user2 = newXiaoShanUserClass(<span class="string">'王医生'</span>, [<span class="string">'外科'</span>, <span class="string">'骨科'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(user2);</span><br></pre></td></tr></table></figure></p>
<p>小结： 构造函数和创建对象分离，符合开放封闭原则。<br>使用场景： 比如根据权限生成不同用户。</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>单例模式理解起来比较简单，就是保证一个类只能存在一个实例，并提供一个访问它的全局接口。单例模式又分懒汉式和饿汉式两种，其区别在于懒汉式在调用的时候创建实例，而饿汉式则是在初始化就创建好实例，具体实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> getInstance () &#123;</span><br><span class="line">   <span class="keyword">if</span> (!Single.instance) &#123;</span><br><span class="line">     Single.instance = <span class="keyword">new</span> Single();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Single.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test1 = Single.getInstance();</span><br><span class="line"><span class="keyword">const</span> test2 = Single.getInstance();</span><br><span class="line"><span class="built_in">console</span>.log(test1 === test2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> instance = <span class="keyword">new</span> Single();</span><br><span class="line">  <span class="keyword">static</span> getInstance () &#123;</span><br><span class="line">    <span class="keyword">return</span> Single.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test1 = Single.getInstance();</span><br><span class="line"><span class="keyword">const</span> test2 = Single.getInstance();</span><br><span class="line"><span class="built_in">console</span>.log(test1 === test2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>小结： 实例如果存在，直接返回已创建的，符合开放封闭原则。<br>使用场景： Redux、Vuex 等状态管理工具，还有我们常用的 window 对象、全局缓存等。</p>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>对于前端来说，原型模式在常见不过了。当新创建的对象和已有对象存在较大共性时，可以通过对象的复制来达到创建新的对象，这就是原型模式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.create()实现原型模式</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line"> name: <span class="string">'zhangsan'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> userOne = <span class="built_in">Object</span>.create(user);</span><br><span class="line"><span class="built_in">console</span>.log(userOne.__proto__); <span class="comment">// &#123;name: "zhangsan", age: 18&#125;</span></span><br><span class="line"><span class="comment">// 原型链继承实现原型模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName () &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">   <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  setName (_name) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.name = _name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> admin = <span class="keyword">new</span> Admin(<span class="string">'zhangsan'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(admin.getName());</span><br><span class="line"><span class="built_in">console</span>.log(admin.setName(<span class="string">'lisi'</span>));</span><br></pre></td></tr></table></figure></p>
<p>小结： 原型模式最简单的实现方式—Object.create()。<br>使用场景： 新创建对象和已有对象无较大差别时，可以使用原型模式来减少创建新对象的成本。</p>
<h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p>讲装饰器模式之前，先聊聊高阶函数。高阶函数就是一个函数就可以接收另一个函数作为参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y, f</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> f(x) + f(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> num = add(<span class="number">2</span>, <span class="number">-2</span>, <span class="built_in">Math</span>.abs);</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p>
<p>函数 add 就是一个简单的高阶函数，而 add 相对于 Math.abs 来说相当于一个装饰器，因此这个例子也可以理解为一个简单的装饰器模式。在 react 中，高阶组件(HOC)也是装饰器模式的一种体现，通常用来不改变原来组件的情况下添加一些属性，达到组件复用的功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> BgHOC = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"> render () &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;div style=&#123;&#123; <span class="attr">background</span>: <span class="string">'blue'</span> &#125;&#125;&gt;</span><br><span class="line">       &lt;WrappedComponent /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>小结： 装饰器模式将现有对象和装饰器进行分离，两者独立存在，符合开放封闭原则和单一职责模式。<br>使用场景： es7 装饰器、vue mixins、core-decorators 等。</p>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>适配器别名包装器，其作用是解决两个软件实体间的接口不兼容的问题。以 axios 源码为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDefaultAdapter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> adapter;</span><br><span class="line">  <span class="comment">// 判断当前是否是 node 环境</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> process !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(process) === <span class="string">'[object process]'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是 node 环境，调用 node 专属的 http 适配器</span></span><br><span class="line">    adapter = <span class="built_in">require</span>(<span class="string">'./adapters/http'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是浏览器环境，调用基于 xhr 的适配器</span></span><br><span class="line">    adapter = <span class="built_in">require</span>(<span class="string">'./adapters/xhr'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// http adapter</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">httpAdapter</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">dispatchHttpRequest</span>(<span class="params">resolvePromise, rejectPromise</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// xhr adapter</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">xhrAdapter</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">dispatchXhrRequest</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其目的就是保证 node 和浏览器环境的入参 config 一致，出参 Promise 都是同一个。<br>小结： 不改变原有接口的情况下，统一接口、统一入参、统一出参、统一规则，符合开发封闭原则。<br>使用场景 ：拥抱变化，兼容代码。</p>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>代理模式就是为对象提供一个代理，用来控制对这个对象的访问。在我们业务开发中最常见的有四种代理类型：事件代理，虚拟代理、缓存代理和保护代理。本文主要介绍虚拟代理和缓存代理两类。提到虚拟代理，其最具代表性的例子就是图片预加载。预加载主要是为了避免网络延迟、或者图片太大引起页面长时间留白的问题。通常的解决方案是先给 img 标签展示一个占位图，然后创建一个 Image 实例，让这个实例的 src 指向真实的目标图片地址，当其真实图片加载完成之后，再将 DOM 上的 img 标签的 src 属性指向真实图片地址。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyImg</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span> (imgELe) &#123;</span><br><span class="line">   <span class="keyword">this</span>.imgELe = imgELe;</span><br><span class="line">    <span class="keyword">this</span>.DEFAULT_URL = <span class="string">'xxx'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  setUrl (targetUrl) &#123;</span><br><span class="line">   <span class="keyword">this</span>.imgEle.src = <span class="keyword">this</span>.DEFAULT_URL;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    </span><br><span class="line">    image.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>.imgEle.src = targetUrl;</span><br><span class="line">    &#125;</span><br><span class="line">    image.src = targetUrl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>缓存代理常用于一些计算量较大的场景。当计算的值已经被出现过的时候，不需要进行第二次重复计算。以传参求和为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countSum = <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'count...'</span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  arg.forEach(<span class="function"><span class="params">v</span> =&gt;</span> result += v);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxyCountSum = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> args = arg.join(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">if</span> (args <span class="keyword">in</span> cache) <span class="keyword">return</span> cache[args];</span><br><span class="line">    <span class="keyword">return</span> cache[args] = countSum(...arg);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)()</span><br><span class="line">proxyCountSum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// count...  10</span></span><br><span class="line">proxyCountSum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p>
<p>小结： 通过修改代理类来增加功能，符合开放封闭模式。<br>使用场景： 图片预加载、缓存服务器、处理跨域以及拦截器等。</p>
<h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>介绍策略模式之前，简单实现一个常见的促销活动规则：</p>
<ul>
<li>预售活动，全场 9.5 折</li>
<li>大促活动，全场 9 折</li>
<li>返场优惠，全场 8.5 折</li>
<li>限时优惠，全场 8 折</li>
</ul>
<p>人人喊打的 if-else<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> activity = <span class="function">(<span class="params">type, price</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (type === <span class="string">'pre'</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> price * <span class="number">0.95</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'onSale'</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> price * <span class="number">0.9</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'back'</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> price * <span class="number">0.85</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">'limit'</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> price * <span class="number">0.8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码存在肉眼可见的问题：大量 if-else、可扩展性差、违背开放封闭原则等。我们再使用策略模式优化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> activity = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line"> [<span class="string">'pre'</span>, (price) =&gt; price * <span class="number">0.95</span>],</span><br><span class="line">  [<span class="string">'onSale'</span>, (price) =&gt; price * <span class="number">0.9</span>],</span><br><span class="line">  [<span class="string">'back'</span>, (price) =&gt; price * <span class="number">0.85</span>],</span><br><span class="line">  [<span class="string">'limit'</span>, (price) =&gt; price * <span class="number">0.8</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> getActivityPrice = <span class="function">(<span class="params">type, price</span>) =&gt;</span> activity.get(type)(price);</span><br><span class="line"><span class="comment">// 新增新手活动</span></span><br><span class="line">activity.set(<span class="string">'newcomer'</span>, (price) =&gt; price * <span class="number">0.7</span>);</span><br></pre></td></tr></table></figure></p>
<p>小结： 定义一系列算法，将其一一封装起来，并且使它们可相互替换。符合开放封闭原则。<br>使用场景： 表单验证、存在大量 if-else 场景、各种重构等。</p>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>观察者模式又叫发布-订阅模式，其用来定义对象之间的一对多依赖关系，以便当一个对象更改状态时，将通知其所有依赖关系。通过“别名”可以知道，观察者模式具备两个角色，即“发布者”和“订阅者”。正如我们工作中的产品经理就是一个“发布者”，而前后端、测试可以理解为“订阅者”。以产品经理建需求沟通群为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义发布者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = [];</span><br><span class="line">    <span class="keyword">this</span>.prdState = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 增加订阅者</span></span><br><span class="line">  add (observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知所有订阅者</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">      observer.update(<span class="keyword">this</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 该方法用于获取当前的 prdState</span></span><br><span class="line">  getState () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prdState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 该方法用于改变 prdState 的值</span></span><br><span class="line">  setState (state) &#123;</span><br><span class="line">    <span class="comment">// prd 的值发生改变</span></span><br><span class="line">    <span class="keyword">this</span>.prdState = state;</span><br><span class="line">    <span class="comment">// 需求文档变更，立刻通知所有开发者</span></span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义订阅者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">  <span class="keyword">this</span>.prdState = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  update (publisher) &#123;</span><br><span class="line">    <span class="comment">// 更新需求文档</span></span><br><span class="line">    <span class="keyword">this</span>.prdState = publisher.getState();</span><br><span class="line">    <span class="comment">// 调用工作函数</span></span><br><span class="line">    <span class="keyword">this</span>.work();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// work 方法，一个专门搬砖的方法</span></span><br><span class="line">  work () &#123;</span><br><span class="line">    <span class="comment">// 获取需求文档</span></span><br><span class="line">    <span class="keyword">const</span> prd = <span class="keyword">this</span>.prdState;</span><br><span class="line">    <span class="built_in">console</span>.log(prd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建订阅者：前端开发小王</span></span><br><span class="line"><span class="keyword">const</span> wang = <span class="keyword">new</span> Observer();</span><br><span class="line"><span class="comment">// 创建订阅者：后端开发小张</span></span><br><span class="line"><span class="keyword">const</span> zhang = <span class="keyword">new</span> Observer();</span><br><span class="line"><span class="comment">// 创建发布者：产品经理小曾</span></span><br><span class="line"><span class="keyword">const</span> zeng = <span class="keyword">new</span> Publisher();</span><br><span class="line"><span class="comment">// 需求文档</span></span><br><span class="line"><span class="keyword">const</span> prd = &#123;</span><br><span class="line">  url: <span class="string">'xxxxxxx'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 小曾开始拉人入群</span></span><br><span class="line">zeng.add(wang);</span><br><span class="line">zeng.add(zhang);</span><br><span class="line"><span class="comment">// 小曾发布需求文档并通知所有人</span></span><br><span class="line">zeng.setState(prd);</span><br></pre></td></tr></table></figure></p>
<p>经常使用 Event Bus(Vue) 和 Event Emitter(node)会发现，发布-订阅模式和观察者模式还是存在着细微差别，即所有事件的发布/订阅都不能由发布者和订阅者“私下联系”，需要委托事件中心处理。以 Vue Event Bus 为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">const</span> EventBus = <span class="keyword">new</span> Vue();</span><br><span class="line">Vue.prototype.$bus = EventBus;</span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line"><span class="keyword">this</span>.$bus.$on(<span class="string">'testEvent'</span>, func);</span><br><span class="line"><span class="comment">// 发布/触发事件</span></span><br><span class="line"><span class="keyword">this</span>.$bus.$emit(<span class="string">'testEvent'</span>, params);</span><br></pre></td></tr></table></figure></p>
<p>整个过程都是 this.$bus 这个“事件中心”在处理。<br>小结： 为解耦而生，为事件而生，符合开放封闭原则。<br>使用场景： 跨层级通信、事件绑定等。</p>
<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p>迭代器模式号称“遍历专家”，它提供一种方法顺序访问一个聚合对象中的各个元素，且不暴露该对象的内部表示。迭代器又分内部迭代器（jquery.each/for…of）和外部迭代器（es6 yield）。在 es6 之前，直接通过 forEach 遍历 DOM NodeList 和函数的 arguments 对象，都会直接报错，其原因都是因为他们都是类数组对象。对此 jquery 很好的兼容了这一点。在 es6 中，它约定只要数据类型具备 Symbol.iterator 属性，就可以被 for…of 循环和迭代器的 next 方法遍历。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> arg = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">const</span> iterator = arg[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">  <span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>通过 es6 内置生成器 Generator 实现迭代器并没什么难度，这里重点通 es5 实现迭代器：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratorGenerator</span> (<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// len 记录传入集合的长度</span></span><br><span class="line">  <span class="keyword">var</span> len = list.length;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义 next 方法</span></span><br><span class="line">    next: funciton () &#123;</span><br><span class="line">      <span class="comment">// 如果索引还没有超出集合长度，done 为 false</span></span><br><span class="line">      <span class="keyword">var</span> done = index &gt;= len;</span><br><span class="line">      <span class="comment">// 如果 done 为 false，则可以继续取值</span></span><br><span class="line">      <span class="keyword">var</span> value = !done ? list[index++] : <span class="literal">undefined</span>;</span><br><span class="line">      <span class="comment">// 将当前值与遍历是否完毕（done）返回</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: done,</span><br><span class="line">        value: value</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iterator = iteratorGenerator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>小结： 实现统一遍历接口，符合单一功能和开放封闭原则。<br>使用场景： 有遍历的地方就有迭代器。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>设计模式的难，在于它的抽象和分散。抽象在于每一设计模式看例子都很好理解，真正使用起来却不知所措；分散则是出现一个场景发现好几种设计模式都能实现。而解决抽象的最好办法就是动手实践，在业务开发中探索使用它们的可能性。本文大致介绍了前端领域常见的 9 种设计模式，相信大家在理解的同时也不难发现，设计模式始终围绕着“封装变化”来提供代码的可读性、扩展性、易维护性。所以当我们工作生活中，始终保持“封装变化”的思想的时候，就已经开始体会到设计模式精髓了。</p>

        </div>

        
            <div class="article-tags tags">
                
                    <a href="/tags/基础知识/"><i class="fa fa-tag"></i>&nbsp;&nbsp;基础知识</a>
                
                    <a href="/tags/面试题/"><i class="fa fa-tag"></i>&nbsp;&nbsp;面试题</a>
                
            </div>
        

        
            <div class="art-item-footer">
                
                    <span class="art-item-left">
                        <i class="fa fa-chevron-left" aria-hidden="true"></i>&nbsp;
                        <a href="/2020/12/16/海量数据页面渲染优化/" rel="prev" title="海量数据页面渲染优化">
                            海量数据页面渲染优化
                        </a>
                    </span>
                
                
                    <span class="art-item-right">
                        <a href="/2020/08/28/web安全之外链target-blank/" rel="next" title="web安全之外链target=_blank">
                            web安全之外链target=_blank
                        </a>&nbsp;
                        <i class="fa fa-chevron-right" aria-hidden="true"></i>
                    </span>
                
            </div>
        

    </section>

</article>

<br>

<!-- 显示推荐文章和评论 -->


<script>
    window.subData = {
        title: '前端常见的设计模式',
        tools: true
    }
</script>


      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>
    
        <img class='avatar waves-image' src='https://avatars2.githubusercontent.com/u/20313228?s=400&u=81b6a332e9a0f8c63e4841766106f3c8f881cfb5&v=4' />
    
</section>


  <section class='m_widget categories'>
<div class='header'><i class="fa fa-sitemap" aria-hidden="true"></i>&nbsp;&nbsp;分类</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/css/"><div class='name'>css</div><div class='badge'>11</div></a></li>
    
        <li><a class="flat-box" href="/categories/javascript/"><div class='name'>javascript</div><div class='badge'>174</div></a></li>
    
        <li><a class="flat-box" href="/categories/nodejs/"><div class='name'>nodejs</div><div class='badge'>19</div></a></li>
    
        <li><a class="flat-box" href="/categories/服务器/"><div class='name'>服务器</div><div class='badge'>15</div></a></li>
    
        <li><a class="flat-box" href="/categories/计算机原理/"><div class='name'>计算机原理</div><div class='badge'>21</div></a></li>
    
    </ul>
    
</div>
</section>


  
<div class="m_widget tagcloud">
    <div class="header"><i class="fa fa-tags" aria-hidden="true"></i>&nbsp;&nbsp;标签</div>
    <div class='content'>
        <a href="/tags/3D/" style="font-size: 14.77px; color: #949494">3D</a> <a href="/tags/AI/" style="font-size: 14px; color: #999">AI</a> <a href="/tags/MYSQL笔记/" style="font-size: 20.15px; color: #6f6f6f">MYSQL笔记</a> <a href="/tags/Threejs/" style="font-size: 15.54px; color: #8f8f8f">Threejs</a> <a href="/tags/ajax/" style="font-size: 17.85px; color: #7f7f7f">ajax</a> <a href="/tags/canvas/" style="font-size: 14px; color: #999">canvas</a> <a href="/tags/cordova/" style="font-size: 14px; color: #999">cordova</a> <a href="/tags/docker/" style="font-size: 14px; color: #999">docker</a> <a href="/tags/github/" style="font-size: 17.85px; color: #7f7f7f">github</a> <a href="/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/tags/html/" style="font-size: 17.08px; color: #848484">html</a> <a href="/tags/jquery/" style="font-size: 15.54px; color: #8f8f8f">jquery</a> <a href="/tags/linux/" style="font-size: 14.77px; color: #949494">linux</a> <a href="/tags/nodejs/" style="font-size: 15.54px; color: #8f8f8f">nodejs</a> <a href="/tags/typescript/" style="font-size: 14px; color: #999">typescript</a> <a href="/tags/vue/" style="font-size: 20.92px; color: #6a6a6a">vue</a> <a href="/tags/webSocket/" style="font-size: 14px; color: #999">webSocket</a> <a href="/tags/webpack/" style="font-size: 17.85px; color: #7f7f7f">webpack</a> <a href="/tags/web图形/" style="font-size: 17.08px; color: #848484">web图形</a> <a href="/tags/web安全/" style="font-size: 17.85px; color: #7f7f7f">web安全</a> <a href="/tags/web性能/" style="font-size: 18.62px; color: #7a7a7a">web性能</a> <a href="/tags/worker/" style="font-size: 14.77px; color: #949494">worker</a> <a href="/tags/兼容性/" style="font-size: 15.54px; color: #8f8f8f">兼容性</a> <a href="/tags/后端/" style="font-size: 15.54px; color: #8f8f8f">后端</a> <a href="/tags/后端代理服务/" style="font-size: 14px; color: #999">后端代理服务</a> <a href="/tags/图片处理/" style="font-size: 17.85px; color: #7f7f7f">图片处理</a> <a href="/tags/基础知识/" style="font-size: 24px; color: #555">基础知识</a> <a href="/tags/少儿编程/" style="font-size: 14px; color: #999">少儿编程</a> <a href="/tags/工具库/" style="font-size: 23.23px; color: #5a5a5a">工具库</a> <a href="/tags/微信/" style="font-size: 14.77px; color: #949494">微信</a> <a href="/tags/手写/" style="font-size: 19.38px; color: #747474">手写</a> <a href="/tags/文章收集/" style="font-size: 14px; color: #999">文章收集</a> <a href="/tags/日语/" style="font-size: 17.85px; color: #7f7f7f">日语</a> <a href="/tags/样式/" style="font-size: 17.85px; color: #7f7f7f">样式</a> <a href="/tags/正则/" style="font-size: 14px; color: #999">正则</a> <a href="/tags/浏览器/" style="font-size: 16.31px; color: #898989">浏览器</a> <a href="/tags/爬虫/" style="font-size: 14px; color: #999">爬虫</a> <a href="/tags/移动端/" style="font-size: 21.69px; color: #656565">移动端</a> <a href="/tags/算法/" style="font-size: 15.54px; color: #8f8f8f">算法</a> <a href="/tags/编译/" style="font-size: 17.08px; color: #848484">编译</a> <a href="/tags/网络基础/" style="font-size: 20.15px; color: #6f6f6f">网络基础</a> <a href="/tags/调试/" style="font-size: 14.77px; color: #949494">调试</a> <a href="/tags/资源导航/" style="font-size: 14.77px; color: #949494">资源导航</a> <a href="/tags/软考/" style="font-size: 14px; color: #999">软考</a> <a href="/tags/面试题/" style="font-size: 22.46px; color: #5f5f5f">面试题</a> <a href="/tags/面试题系列/" style="font-size: 17.85px; color: #7f7f7f">面试题系列</a>
    </div>
</div>




      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">
    <div class="social-wrapper">
      
    </div>
    <br>
    <div>博客内容遵循 <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="licenses">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></div>
    <div>本站使用 <a href="https://github.com/xaoxuu/hexo-theme-material-x" target="_blank" class="codename">Material-X</a> 作为主题，
		总访问量为 <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
    </div>

</footer>

  <script>setLoadingBarProgress(80);</script>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>
<!-- 访问统计 -->
<!-- <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- 推荐文章 -->
<!-- <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> -->
<!-- <script src="//unpkg.com/valine/dist/Valine.min.js"></script> -->
<script src="/js/jquery.fitvids.js"></script>
<script>
var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
var ALGOLIA_API_KEY = "";
var ALGOLIA_APP_ID = "";
var ALGOLIA_INDEX_NAME = "";
var AZURE_SERVICE_NAME = "";
var AZURE_INDEX_NAME = "";
var AZURE_QUERY_KEY = "";
var BAIDU_API_ID = "";
var SEARCH_SERVICE = "hexo";
var ROOT = "/"||"/";
if(!ROOT.endsWith('/'))ROOT += '/';
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


    
    
    


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
